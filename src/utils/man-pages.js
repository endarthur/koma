/**
 * Man Pages Content
 * Auto-generated by build-man-pages.py
 * DO NOT EDIT - Edit files in docs/man/ instead
 */

export const manPages = {
  'cat.1.md': `# NAME

cat - concatenate and display files

## SYNOPSIS

\`cat <file>\`

## DESCRIPTION

Read files and write their contents to the terminal. Displays the complete file contents.

## EXAMPLES

Display a file:
\`\`\`
cat file.txt
\`\`\`

Display a script:
\`\`\`
cat /home/hello.js
\`\`\`

## SEE ALSO

head(1), tail(1), vein(1)
`,

  'cd.1.md': `# NAME

cd - change directory

## SYNOPSIS

\`cd [directory]\`

## DESCRIPTION

Change the current working directory. If no directory is specified, changes to the home directory (/home).

Special paths:
- **~** - Home directory (/home)
- **..** - Parent directory
- **/** - Root directory

## EXAMPLES

Change to home:
\`\`\`
cd
cd ~
\`\`\`

Change to parent:
\`\`\`
cd ..
\`\`\`

Change to absolute path:
\`\`\`
cd /usr/bin
\`\`\`

Change to relative path:
\`\`\`
cd projects
\`\`\`

## SEE ALSO

pwd(1), ls(1)
`,

  'cp.1.md': `# NAME

cp - copy files

## SYNOPSIS

\`cp <source> <destination>\`

## DESCRIPTION

Copy a file to a new location. If the destination is a directory, the file is copied into it. Otherwise, creates a new file with the destination name.

Currently only supports copying files, not directories.

## EXAMPLES

Copy a file:
\`\`\`
cp file.txt backup.txt
\`\`\`

Copy into a directory:
\`\`\`
cp script.js /usr/bin/
\`\`\`

Copy with absolute paths:
\`\`\`
cp /home/config.json /tmp/config.json
\`\`\`

## SEE ALSO

mv(1), rm(1), cat(1)
`,

  'grep.1.md': `# NAME

grep - search file contents

## SYNOPSIS

\`grep <pattern> <file>\`

## DESCRIPTION

Search for lines in a file matching a pattern (regular expression). Displays all matching lines.

## EXAMPLES

Search for a word:
\`\`\`
grep error log.txt
\`\`\`

Search for a pattern:
\`\`\`
grep "^import" script.js
\`\`\`

Search in home directory:
\`\`\`
grep TODO /home/notes.txt
\`\`\`

## SEE ALSO

cat(1), head(1), tail(1), wc(1)
`,

  'head.1.md': `# NAME

head - display first lines of file

## SYNOPSIS

\`head <file> [-n lines]\`

## DESCRIPTION

Display the first 10 lines of a file. Use the -n option to specify a different number of lines.

## OPTIONS

**-n NUM**
  Display NUM lines instead of the default 10.

## EXAMPLES

Show first 10 lines:
\`\`\`
head log.txt
\`\`\`

Show first 5 lines:
\`\`\`
head -n 5 log.txt
\`\`\`

Show first 20 lines:
\`\`\`
head -n 20 /home/script.js
\`\`\`

## SEE ALSO

tail(1), cat(1), grep(1), wc(1)
`,

  'ls.1.md': `# NAME

ls - list directory contents

## SYNOPSIS

\`ls [options] [path]\`

## DESCRIPTION

List information about files and directories. By default, lists the current working directory.

## OPTIONS

**-l**
  Use long listing format, showing permissions, size, and modification date.

## EXAMPLES

List current directory:
\`\`\`
ls
\`\`\`

List with details:
\`\`\`
ls -l
\`\`\`

List specific directory:
\`\`\`
ls /usr/bin
\`\`\`

## SEE ALSO

cd(1), tree(1), pwd(1)
`,

  'mkdir.1.md': `# NAME

mkdir - create directories

## SYNOPSIS

\`mkdir <directory> [directories...]\`

## DESCRIPTION

Create one or more directories in the virtual filesystem. Parent directories must exist (no recursive creation).

## EXAMPLES

Create a directory:
\`\`\`
mkdir projects
\`\`\`

Create multiple directories:
\`\`\`
mkdir docs logs temp
\`\`\`

Create in absolute path:
\`\`\`
mkdir /home/workspace
\`\`\`

## SEE ALSO

rm(1), touch(1), ls(1)
`,

  'mv.1.md': `# NAME

mv - move or rename files and directories

## SYNOPSIS

\`mv <source> <destination>\`

## DESCRIPTION

Move or rename files and directories. If the destination is a directory, the source is moved into it. Otherwise, the source is renamed to the destination name.

Works with both files and directories.

## EXAMPLES

Rename a file:
\`\`\`
mv old-name.txt new-name.txt
\`\`\`

Move into directory:
\`\`\`
mv file.txt /home/documents/
\`\`\`

Rename a directory:
\`\`\`
mv old-dir new-dir
\`\`\`

Move directory:
\`\`\`
mv /tmp/cache /home/backup/
\`\`\`

## SEE ALSO

cp(1), rm(1), cd(1)
`,

  'pwd.1.md': `# NAME

pwd - print working directory

## SYNOPSIS

\`pwd\`

## DESCRIPTION

Display the absolute path of the current working directory.

## EXAMPLES

Show current directory:
\`\`\`
pwd
\`\`\`

## SEE ALSO

cd(1), ls(1)
`,

  'rm.1.md': `# NAME

rm - remove files and directories

## SYNOPSIS

\`rm <path> [paths...]\`

## DESCRIPTION

Delete one or more files or directories from the virtual filesystem. Directories are removed recursively.

**Warning:** This operation is permanent and cannot be undone.

## EXAMPLES

Remove a file:
\`\`\`
rm old-file.txt
\`\`\`

Remove multiple files:
\`\`\`
rm file1.txt file2.txt temp.log
\`\`\`

Remove a directory:
\`\`\`
rm /tmp/cache
\`\`\`

## SEE ALSO

mkdir(1), touch(1), cp(1), mv(1)
`,

  'stat.1.md': `# NAME

stat - display file status

## SYNOPSIS

\`stat <file>\`

## DESCRIPTION

Display detailed information about a file or directory, including:
- File type (file or directory)
- Size in bytes
- Inode number
- Timestamps (created, modified, accessed)
- Permissions

## EXAMPLES

Show file information:
\`\`\`
stat file.txt
\`\`\`

Show directory information:
\`\`\`
stat /home
\`\`\`

Check script details:
\`\`\`
stat /usr/bin/script.js
\`\`\`

## SEE ALSO

ls(1), wc(1), cat(1)
`,

  'tail.1.md': `# NAME

tail - display last lines of file

## SYNOPSIS

\`tail <file> [-n lines]\`

## DESCRIPTION

Display the last 10 lines of a file. Use the -n option to specify a different number of lines.

## OPTIONS

**-n NUM**
  Display NUM lines instead of the default 10.

## EXAMPLES

Show last 10 lines:
\`\`\`
tail log.txt
\`\`\`

Show last 5 lines:
\`\`\`
tail -n 5 log.txt
\`\`\`

Show last 20 lines:
\`\`\`
tail -n 20 /home/output.log
\`\`\`

## SEE ALSO

head(1), cat(1), grep(1), wc(1)
`,

  'touch.1.md': `# NAME

touch - create empty files

## SYNOPSIS

\`touch <file> [files...]\`

## DESCRIPTION

Create one or more empty files in the virtual filesystem. If the file already exists, updates its modification timestamp.

## EXAMPLES

Create a file:
\`\`\`
touch README.md
\`\`\`

Create multiple files:
\`\`\`
touch file1.txt file2.txt file3.txt
\`\`\`

Update timestamp:
\`\`\`
touch existing-file.txt
\`\`\`

## SEE ALSO

mkdir(1), rm(1), vein(1), write(1)
`,

  'tree.1.md': `# NAME

tree - display directory tree structure

## SYNOPSIS

\`tree [path]\`

## DESCRIPTION

Display the directory structure as a tree. Shows files and subdirectories in a hierarchical format. If no path is specified, displays the current working directory.

## EXAMPLES

Show current directory tree:
\`\`\`
tree
\`\`\`

Show specific directory:
\`\`\`
tree /usr
\`\`\`

Show home directory tree:
\`\`\`
tree /home
\`\`\`

## SEE ALSO

ls(1), pwd(1), cd(1)
`,

  'vein.1.md': `# NAME

vein - text editor

## SYNOPSIS

\`vein <file> [options]\`

## DESCRIPTION

Open files in the CodeMirror text editor. Creates new files if they don't exist. The editor provides a clean interface for editing text files in the virtual filesystem.

## OPTIONS

**-f, --force**
  Open file even if the editor has unsaved changes.

## KEYBOARD SHORTCUTS

**F2 / Ctrl+\`**
  Toggle between terminal and editor

**Ctrl+S**
  Save file

**Esc**
  Close editor (prompts if unsaved changes)

**Ctrl+Z**
  Undo

## EXAMPLES

Edit a file:
\`\`\`
vein file.txt
\`\`\`

Force open:
\`\`\`
vein test.js --force
\`\`\`

Create and edit new file:
\`\`\`
vein /home/notes.md
\`\`\`

## SEE ALSO

cat(1), write(1)
`,

  'wc.1.md': `# NAME

wc - word, line, and byte count

## SYNOPSIS

\`wc <file> [-l] [-w] [-c]\`

## DESCRIPTION

Count lines, words, and bytes in a file. Without options, displays all three counts.

## OPTIONS

**-l**
  Show only line count.

**-w**
  Show only word count.

**-c**
  Show only byte count (character count).

## EXAMPLES

Show all counts:
\`\`\`
wc file.txt
\`\`\`

Count lines only:
\`\`\`
wc -l script.js
\`\`\`

Count words only:
\`\`\`
wc -w document.txt
\`\`\`

## SEE ALSO

cat(1), head(1), tail(1), stat(1)
`,

  'write.1.md': `# NAME

write - write text to file from stdin

## SYNOPSIS

\`write <file>\`

## DESCRIPTION

Write text content to a file. Prompts for input line by line. Enter a blank line to finish and save the file.

Useful for quickly creating files with text content without opening the editor.

## EXAMPLES

Write to a file:
\`\`\`
write notes.txt
\`\`\`

Then type lines of text, pressing Enter after each line. Press Enter on a blank line to finish.

Write to a script:
\`\`\`
write /home/script.js
\`\`\`

## SEE ALSO

vein(1), cat(1), touch(1), echo(1)
`,

  'clear.1.md': `# NAME

clear - clear the terminal screen

## SYNOPSIS

\`clear\`

## DESCRIPTION

Clear the terminal screen and scroll buffer. The prompt is displayed at the top of the terminal.

Also accessible via the Ctrl+L keyboard shortcut.

## EXAMPLES

Clear screen:
\`\`\`
clear
\`\`\`

## SEE ALSO

history(1), help(1)
`,

  'cron.1.md': `# NAME

cron - schedule periodic script execution

## SYNOPSIS

\`cron <schedule> <script>\`

## DESCRIPTION

Schedule a JavaScript file to run periodically based on a cron expression. Jobs continue running across sessions.

## SCHEDULE FORMAT

Five fields: **minute hour day month weekday**

- ***** - Any value (matches all)
- ****/N** - Every N (e.g., */5 = every 5 minutes)
- **N-M** - Range from N to M
- **N,M,P** - List of specific values

Field ranges:
- minute: 0-59
- hour: 0-23
- day: 1-31
- month: 1-12
- weekday: 0-6 (0 = Sunday)

## EXAMPLES

Every 5 minutes:
\`\`\`
cron "*/5 * * * *" /home/backup.js
\`\`\`

Every 2 hours:
\`\`\`
cron "0 */2 * * *" /home/check.js
\`\`\`

9:30 AM on weekdays:
\`\`\`
cron "30 9 * * 1-5" /home/work.js
\`\`\`

First day of each month:
\`\`\`
cron "0 0 1 * *" /home/monthly.js
\`\`\`

## SEE ALSO

cronlist(1), cronrm(1), run(1)
`,

  'cronlist.1.md': `# NAME

cronlist - list scheduled cron jobs

## SYNOPSIS

\`cronlist\`

## DESCRIPTION

Display all scheduled cron jobs with their:
- Job ID (for use with cronrm)
- Cron schedule expression
- Script path
- Next scheduled execution time

Cron jobs persist across page reloads and continue executing in the background.

## EXAMPLES

List all cron jobs:
\`\`\`
cronlist
\`\`\`

## SEE ALSO

cron(1), cronrm(1), ps(1)
`,

  'cronrm.1.md': `# NAME

cronrm - remove scheduled cron job

## SYNOPSIS

\`cronrm <job_id>\`

## DESCRIPTION

Remove a scheduled cron job by its job ID. The job will no longer execute.

Use \`cronlist\` to display all jobs and their IDs.

## EXAMPLES

Remove job with ID 1:
\`\`\`
cronrm 1
\`\`\`

List jobs and remove one:
\`\`\`
cronlist
cronrm 3
\`\`\`

## SEE ALSO

cron(1), cronlist(1), kill(1)
`,

  'echo.1.md': `# NAME

echo - display text

## SYNOPSIS

\`echo [text...]\`

## DESCRIPTION

Display arguments as text to the terminal. Joins all arguments with spaces.

## EXAMPLES

Print a message:
\`\`\`
echo Hello, World!
\`\`\`

Print multiple words:
\`\`\`
echo The quick brown fox
\`\`\`

Print with quotes:
\`\`\`
echo "This is a quoted string"
\`\`\`

## SEE ALSO

write(1), cat(1)
`,

  'env.1.md': `# NAME

env - display environment variables

## SYNOPSIS

\`env\`

## DESCRIPTION

Display all environment variables and their values. Environment variables are available to all scripts executed with the \`run\` command.

Default environment variables:
- **HOME** - User home directory (/home)
- **USER** - Username (koma)
- **PATH** - Binary search path (/usr/bin)
- **PWD** - Current working directory
- **SHELL** - Shell name (koma)

## EXAMPLES

Show all environment variables:
\`\`\`
env
\`\`\`

## SEE ALSO

run(1), pwd(1)
`,

  'exit.1.md': `# NAME

exit - close current terminal tab

## SYNOPSIS

\`exit\`

## DESCRIPTION

Close the current terminal tab. If this is the last tab, a new default tab will be created.

Tab state (history, working directory) is lost when closed. Use tab persistence (automatic) to restore tabs on page reload.

## EXAMPLES

Close current tab:
\`\`\`
exit
\`\`\`

## SEE ALSO

restart(1), clear(1)
`,

  'help.1.md': `# NAME

help - display available commands

## SYNOPSIS

\`help\`

## DESCRIPTION

Show a list of all available commands with brief descriptions. Also displays keyboard shortcuts and command mode usage.

For detailed information about a specific command, use the man command.

## EXAMPLES

Show all commands:
\`\`\`
help
\`\`\`

Get detailed help for a command:
\`\`\`
man ls
man run
\`\`\`

## SEE ALSO

man(1)
`,

  'history.1.md': `# NAME

history - display command history

## SYNOPSIS

\`history\`

## DESCRIPTION

Display the command history for the current terminal tab. Each tab maintains its own independent command history.

Navigate history with Up/Down arrow keys while typing commands.

## EXAMPLES

Show command history:
\`\`\`
history
\`\`\`

## SEE ALSO

clear(1), help(1)
`,

  'kill.1.md': `# NAME

kill - terminate a process

## SYNOPSIS

\`kill <pid>\`

## DESCRIPTION

Terminate a running process by its process ID (PID). The process is immediately stopped and marked as killed.

Use the \`ps\` command to list running processes and their PIDs.

## EXAMPLES

Kill process 123:
\`\`\`
kill 123
\`\`\`

List processes to find PID:
\`\`\`
ps
kill 456
\`\`\`

## SEE ALSO

ps(1), run(1), cron(1)
`,

  'man.1.md': `# NAME

man - display manual pages

## SYNOPSIS

\`man <command>\`

## DESCRIPTION

Display the manual page for a command. Manual pages provide detailed information about command usage, options, examples, and related commands.

Manual pages use standard sections:
- **NAME** - Command name and brief description
- **SYNOPSIS** - Command syntax
- **DESCRIPTION** - Detailed description
- **OPTIONS** - Available flags and options (if any)
- **EXAMPLES** - Usage examples
- **SEE ALSO** - Related commands

## EXAMPLES

Read ls manual:
\`\`\`
man ls
\`\`\`

Read run manual:
\`\`\`
man run
\`\`\`

Read cron manual:
\`\`\`
man cron
\`\`\`

## SEE ALSO

help(1), version(1)
`,

  'ps.1.md': `# NAME

ps - list running processes

## SYNOPSIS

\`ps\`

## DESCRIPTION

Display all running and recent processes. Shows process ID, status, runtime, and script path.

Process states:
- **running** - Currently executing
- **completed** - Finished successfully
- **failed** - Exited with error
- **killed** - Terminated by kill command

## EXAMPLES

List all processes:
\`\`\`
ps
\`\`\`

## SEE ALSO

run(1), kill(1)
`,

  'restart.1.md': `# NAME

restart - restart the Olivine kernel

## SYNOPSIS

\`restart\`

## DESCRIPTION

Restart the Olivine kernel (Web Worker). This reinitializes the virtual filesystem from IndexedDB and reloads all system state.

Useful for troubleshooting or applying system changes. All tabs and terminal sessions remain active.

**Warning:** Running processes and cron jobs will be terminated.

## EXAMPLES

Restart kernel:
\`\`\`
restart
\`\`\`

## SEE ALSO

version(1), ps(1), cronlist(1)
`,

  'run.1.md': `# NAME

run - execute JavaScript file as a process

## SYNOPSIS

\`run <script> [args...]\`

## DESCRIPTION

Execute a JavaScript file in the Olivine kernel. The script runs with access to the Koma standard library and can receive command-line arguments.

Scripts have access to:
- **args** - Command-line arguments array
- **env** - Environment variables object
- **console** - Console for stdout/stderr (log, error)
- **fs** - Filesystem module (readFile, writeFile, mkdir, etc.)
- **http** - HTTP module (get, post, json, text)
- **notify** - Notifications module
- **path** - Path utilities (join, resolve, dirname, etc.)
- **argparse** - Argument parsing (parse, usage, hasFlag, etc.)

## EXAMPLES

Run a script:
\`\`\`
run /home/hello.js
\`\`\`

Run with arguments:
\`\`\`
run script.js arg1 arg2
\`\`\`

Example script (/home/hello.js):
\`\`\`
console.log('Hello from Koma!');
console.log('Arguments:', args);
console.log('Home directory:', env.HOME);

const files = await fs.readdir(env.HOME);
console.log('Files in home:', files);
\`\`\`

## SEE ALSO

ps(1), kill(1), cron(1)
`,

  'version.1.md': `# NAME

version - display Koma version information

## SYNOPSIS

\`version\`

## DESCRIPTION

Display version information for Koma terminal, including:
- Koma version number
- Olivine kernel version
- Project description
- GitHub repository URL

## EXAMPLES

Show version information:
\`\`\`
version
\`\`\`

## SEE ALSO

help(1)
`,

  'argparse.3.md': `# NAME

argparse - command-line argument parsing for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'argparse' module
const parsed = argparse.parse(args, {
  flags: {
    verbose: { short: 'v', description: 'Verbose output' }
  },
  options: {
    output: { short: 'o', description: 'Output file' }
  }
});

console.log('Verbose:', parsed.flags.verbose);
console.log('Output:', parsed.options.output);
\`\`\`

## DESCRIPTION

The \`argparse\` module provides robust command-line argument parsing for Koma scripts. It supports boolean flags, options with values, positional arguments, combined short flags, and automatic help text generation.

This is the same module used by built-in Koma commands.

## SCHEMA FORMAT

Argument schemas define what arguments your script accepts:

\`\`\`javascript
const schema = {
  description: 'Brief description of the script',

  flags: {
    flagName: {
      short: 'f',                  // Short form: -f
      description: 'Flag description'
    }
  },

  options: {
    optionName: {
      short: 'o',                  // Short form: -o
      description: 'Option description',
      default: 'defaultValue',     // Optional default
      choices: ['a', 'b', 'c']     // Optional allowed values
    }
  },

  positional: {
    description: '<input> [output]'  // Positional args format
  },

  examples: [
    { command: 'script.js input.txt', description: 'Process input.txt' }
  ],

  notes: [
    'Additional note 1',
    'Additional note 2'
  ],

  seeAlso: ['other-command', 'man page']
};
\`\`\`

## FUNCTIONS

### argparse.parse(argv, schema)

Parse command-line arguments according to a schema.

**Parameters:**
- \`argv\` (Array\\<string\\>) - Arguments array (usually from \`args\` global)
- \`schema\` (object, optional) - Argument schema defining flags and options

**Returns:** object - Parsed arguments with properties:
- \`flags\` (object) - Boolean flags (true/false)
- \`options\` (object) - Options with values
- \`positional\` (array) - Positional arguments
- \`_\` (array) - Alias for positional
- \`errors\` (array) - Parsing errors (if any)

**Example:**
\`\`\`javascript
const schema = {
  flags: {
    verbose: { short: 'v' },
    quiet: { short: 'q' }
  },
  options: {
    output: { short: 'o' },
    format: { short: 'f', choices: ['json', 'text'] }
  }
};

const parsed = argparse.parse(args, schema);

if (parsed.errors.length > 0) {
  parsed.errors.forEach(err => console.error('Error:', err));
  return;
}

if (parsed.flags.verbose) {
  console.log('Verbose mode enabled');
}

if (parsed.options.output) {
  console.log('Output to:', parsed.options.output);
}

console.log('Files:', parsed.positional);
\`\`\`

### argparse.usage(commandName, schema)

Generate formatted usage text from a schema.

**Parameters:**
- \`commandName\` (string) - Name of the command/script
- \`schema\` (object) - Argument schema

**Returns:** Array\\<string\\> - Array of formatted lines

**Example:**
\`\`\`javascript
const usage = argparse.usage('myscript', schema);
usage.forEach(line => console.log(line));
\`\`\`

### argparse.hasHelp(argv)

Check if help flag is present (--help or -h).

**Parameters:**
- \`argv\` (Array\\<string\\>) - Arguments array

**Returns:** boolean - True if help flag present

**Example:**
\`\`\`javascript
if (argparse.hasHelp(args)) {
  console.log('Help requested');
}
\`\`\`

### argparse.showHelp(commandName, argv, schema, term)

Display help text if help flag is present. This is a convenience function used by built-in commands.

**Parameters:**
- \`commandName\` (string) - Command name
- \`argv\` (Array\\<string\\>) - Arguments array
- \`schema\` (object) - Argument schema
- \`term\` (object) - Terminal with writeln method (for internal use)

**Returns:** boolean - True if help was shown

**Note:** In scripts, use \`hasHelp()\` and \`usage()\` instead since you don't have access to the terminal object.

### argparse.hasFlag(argv, flag)

Quick check if a specific flag is present.

**Parameters:**
- \`argv\` (Array\\<string\\>) - Arguments array
- \`flag\` (string) - Flag name (with or without --)

**Returns:** boolean - True if flag present

**Example:**
\`\`\`javascript
if (argparse.hasFlag(args, '--verbose')) {
  console.log('Verbose mode');
}
if (argparse.hasFlag(args, 'v')) {
  console.log('Short form -v present');
}
\`\`\`

### argparse.getOption(argv, option, defaultValue)

Get value of a specific option.

**Parameters:**
- \`argv\` (Array\\<string\\>) - Arguments array
- \`option\` (string) - Option name (with or without --)
- \`defaultValue\` (any, optional) - Default if not present

**Returns:** any - Option value or default

**Example:**
\`\`\`javascript
const output = argparse.getOption(args, 'output', 'default.txt');
console.log('Output file:', output);
\`\`\`

## ARGUMENT FORMATS

### Boolean flags

\`\`\`bash
script.js --verbose           # Long form
script.js -v                  # Short form
script.js -v --quiet          # Multiple flags
script.js -vq                 # Combined short flags
\`\`\`

### Options with values

\`\`\`bash
script.js --output=file.txt   # Long form with =
script.js --output file.txt   # Long form with space
script.js -o file.txt         # Short form with space
script.js -vo output.txt      # Combined flags + option
\`\`\`

### Positional arguments

\`\`\`bash
script.js file1.txt file2.txt    # Positional args
script.js -v file1.txt file2.txt # Flags + positional
\`\`\`

### Stop parsing with --

\`\`\`bash
script.js -- --not-a-flag     # Everything after -- is positional
\`\`\`

## COMPLETE EXAMPLES

### Simple script with flags

\`\`\`javascript
// myscript.js - Count lines in files
const schema = {
  description: 'Count lines in files',
  flags: {
    verbose: { short: 'v', description: 'Show detailed output' },
    total: { short: 't', description: 'Show total only' }
  },
  positional: { description: '<file> [files...]' },
  examples: [
    { command: 'myscript.js file.txt', description: 'Count lines in file' },
    { command: 'myscript.js -v *.txt', description: 'Verbose output' }
  ]
};

// Show help if requested
if (argparse.hasHelp(args)) {
  const usage = argparse.usage('myscript.js', schema);
  usage.forEach(line => console.log(line));
  return;
}

// Parse arguments
const parsed = argparse.parse(args, schema);

if (parsed.errors.length > 0) {
  parsed.errors.forEach(err => console.error('Error:', err));
  return;
}

if (parsed.positional.length === 0) {
  console.error('Error: No files specified');
  return;
}

// Process files
let totalLines = 0;
for (const file of parsed.positional) {
  const content = await fs.readFile(file);
  const lines = content.split('\\n').length;
  totalLines += lines;

  if (!parsed.flags.total) {
    console.log(\`\${lines} \${file}\`);
  }
}

if (parsed.flags.verbose || parsed.flags.total) {
  console.log(\`Total: \${totalLines} lines\`);
}
\`\`\`

### Script with options and validation

\`\`\`javascript
// converter.js - Convert file formats
const schema = {
  description: 'Convert file between formats',
  flags: {
    force: { short: 'f', description: 'Overwrite existing files' }
  },
  options: {
    format: {
      short: 'F',
      description: 'Output format',
      choices: ['json', 'yaml', 'toml'],
      default: 'json'
    },
    output: {
      short: 'o',
      description: 'Output file'
    }
  },
  positional: { description: '<input>' },
  examples: [
    { command: 'converter.js data.yaml', description: 'Convert to JSON' },
    { command: 'converter.js -F yaml data.json', description: 'Convert to YAML' },
    { command: 'converter.js -o out.json data.yaml', description: 'Specify output' }
  ]
};

if (argparse.hasHelp(args)) {
  argparse.usage('converter.js', schema).forEach(line => console.log(line));
  return;
}

const parsed = argparse.parse(args, schema);

// Check for errors (includes validation of choices)
if (parsed.errors.length > 0) {
  parsed.errors.forEach(err => console.error(err));
  return;
}

// Validate required arguments
if (parsed.positional.length === 0) {
  console.error('Error: Input file required');
  return;
}

const input = parsed.positional[0];
const format = parsed.options.format;
const output = parsed.options.output || input.replace(/\\.\\w+$/, \`.\${format}\`);

console.log(\`Converting \${input} to \${format} format...\`);
console.log(\`Output: \${output}\`);

// Check if output exists
if (await fs.exists(output) && !parsed.flags.force) {
  console.error(\`Error: \${output} exists. Use --force to overwrite.\`);
  return;
}

// Conversion logic would go here...
\`\`\`

### Using quick parse functions

\`\`\`javascript
// Simple flag checking without full parsing
if (argparse.hasFlag(args, 'help')) {
  console.log('Usage: script.js [options] <files...>');
  return;
}

const verbose = argparse.hasFlag(args, 'verbose');
const output = argparse.getOption(args, 'output', 'default.txt');

if (verbose) {
  console.log(\`Output file: \${output}\`);
}
\`\`\`

## NOTES

- All flags are optional and default to false
- Options can have default values and validation via choices
- Combined short flags like \`-abc\` expand to \`-a -b -c\`
- Last character in combined flags can be an option: \`-vo file.txt\` = \`-v -o file.txt\`
- Use \`--\` to stop parsing flags (everything after is positional)
- Schema is optional - parse() works without one for simple cases
- Error checking is important - always check \`parsed.errors.length\`

## SEE ALSO

run(1), env(1), echo(1)
`,

  'fs.3.md': `# NAME

fs - filesystem API for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'fs' module
const content = await fs.readFile('/home/file.txt');
await fs.writeFile('/home/output.txt', 'Hello, World!');
const files = await fs.readdir('/home');
\`\`\`

## DESCRIPTION

The \`fs\` module provides access to the virtual filesystem (VFS) from JavaScript scripts executed with the \`run\` command. All operations are asynchronous and return Promises.

## FUNCTIONS

### fs.readFile(path)

Read file contents as a string.

**Parameters:**
- \`path\` (string) - File path to read

**Returns:** Promise\\<string\\> - File contents

**Throws:** Error with 'ENOENT' if file doesn't exist

**Example:**
\`\`\`javascript
const content = await fs.readFile('/home/config.json');
const config = JSON.parse(content);
console.log('Config loaded:', config);
\`\`\`

### fs.writeFile(path, content)

Write content to a file. Creates the file if it doesn't exist, overwrites if it does.

**Parameters:**
- \`path\` (string) - File path to write
- \`content\` (string) - Content to write

**Returns:** Promise\\<void\\>

**Example:**
\`\`\`javascript
await fs.writeFile('/home/log.txt', 'Application started\\n');
console.log('Log file created');
\`\`\`

### fs.appendFile(path, content)

Append content to a file. Creates the file if it doesn't exist.

**Parameters:**
- \`path\` (string) - File path to append to
- \`content\` (string) - Content to append

**Returns:** Promise\\<void\\>

**Example:**
\`\`\`javascript
await fs.appendFile('/home/log.txt', 'New log entry\\n');
\`\`\`

### fs.readdir(path)

Read directory contents.

**Parameters:**
- \`path\` (string) - Directory path to read

**Returns:** Promise\\<Array\\<Object\\>\\> - Array of directory entries with properties:
- \`name\` (string) - Entry name
- \`type\` (string) - 'file' or 'directory'
- \`size\` (number) - Size in bytes (files only)
- \`modified\` (Date) - Last modified timestamp

**Example:**
\`\`\`javascript
const entries = await fs.readdir('/home');
for (const entry of entries) {
  console.log(\`\${entry.type}: \${entry.name}\`);
}
\`\`\`

### fs.mkdir(path)

Create a directory.

**Parameters:**
- \`path\` (string) - Directory path to create

**Returns:** Promise\\<void\\>

**Throws:** Error if parent directory doesn't exist

**Example:**
\`\`\`javascript
await fs.mkdir('/home/projects');
console.log('Directory created');
\`\`\`

### fs.unlink(path)

Delete a file or empty directory.

**Parameters:**
- \`path\` (string) - Path to delete

**Returns:** Promise\\<void\\>

**Throws:** Error if directory is not empty

**Example:**
\`\`\`javascript
await fs.unlink('/home/temp.txt');
console.log('File deleted');
\`\`\`

### fs.rename(oldPath, newPath)

Rename or move a file or directory.

**Parameters:**
- \`oldPath\` (string) - Current path
- \`newPath\` (string) - New path

**Returns:** Promise\\<void\\>

**Example:**
\`\`\`javascript
await fs.rename('/home/old.txt', '/home/new.txt');
console.log('File renamed');
\`\`\`

### fs.stat(path)

Get file or directory metadata.

**Parameters:**
- \`path\` (string) - Path to stat

**Returns:** Promise\\<Object\\> - Metadata object with properties:
- \`type\` (string) - 'file' or 'directory'
- \`size\` (number) - Size in bytes
- \`inode\` (number) - Inode number
- \`created\` (Date) - Creation timestamp
- \`modified\` (Date) - Last modified timestamp
- \`accessed\` (Date) - Last accessed timestamp

**Example:**
\`\`\`javascript
const stat = await fs.stat('/home/file.txt');
console.log(\`Size: \${stat.size} bytes\`);
console.log(\`Modified: \${stat.modified}\`);
\`\`\`

### fs.exists(path)

Check if a path exists.

**Parameters:**
- \`path\` (string) - Path to check

**Returns:** Promise\\<boolean\\> - True if exists, false otherwise

**Example:**
\`\`\`javascript
if (await fs.exists('/home/config.json')) {
  console.log('Config file exists');
} else {
  console.log('Config file not found');
}
\`\`\`

### fs.isFile(path)

Check if a path is a file.

**Parameters:**
- \`path\` (string) - Path to check

**Returns:** Promise\\<boolean\\> - True if path exists and is a file

**Example:**
\`\`\`javascript
if (await fs.isFile('/home/script.js')) {
  console.log('It is a file');
}
\`\`\`

### fs.isDirectory(path)

Check if a path is a directory.

**Parameters:**
- \`path\` (string) - Path to check

**Returns:** Promise\\<boolean\\> - True if path exists and is a directory

**Example:**
\`\`\`javascript
if (await fs.isDirectory('/home')) {
  console.log('It is a directory');
}
\`\`\`

## COMPLETE EXAMPLE

\`\`\`javascript
// Create a backup script
const source = '/home/data.txt';
const backup = '/home/data.backup.txt';

// Check if source exists
if (await fs.exists(source)) {
  // Read source content
  const content = await fs.readFile(source);

  // Write backup
  await fs.writeFile(backup, content);

  // Verify backup
  const stat = await fs.stat(backup);
  console.log(\`Backup created: \${stat.size} bytes\`);
} else {
  console.error('Source file not found');
}
\`\`\`

## SEE ALSO

run(1), path(3), cat(1), ls(1), mkdir(1)
`,

  'http.3.md': `# NAME

http - HTTP client API for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'http' module
const response = await http.get('https://api.example.com/data');
const data = await http.json('https://api.example.com/users');
await http.post('https://api.example.com/submit', { name: 'Alice' });
\`\`\`

## DESCRIPTION

The \`http\` module provides a simplified interface for making HTTP requests from JavaScript scripts. It wraps the browser's \`fetch()\` API with convenient methods for common operations.

All functions return Promises and can be used with async/await.

## FUNCTIONS

### http.fetch(url, options)

Make a raw HTTP request using the Fetch API.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Fetch options (method, headers, body, etc.)

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
const response = await http.fetch('https://api.example.com/data', {
  method: 'GET',
  headers: { 'Authorization': 'Bearer token123' }
});
console.log('Status:', response.status);
\`\`\`

### http.get(url, options)

Make a GET request.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Additional fetch options

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
const response = await http.get('https://api.example.com/users');
const users = await response.json();
console.log('Users:', users);
\`\`\`

### http.post(url, body, options)

Make a POST request. Automatically stringifies objects to JSON and sets Content-Type header.

**Parameters:**
- \`url\` (string) - URL to request
- \`body\` (any) - Request body (objects are JSON stringified)
- \`options\` (object, optional) - Additional fetch options

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
const response = await http.post('https://api.example.com/users', {
  name: 'Alice',
  email: 'alice@example.com'
});
console.log('Created:', await response.json());
\`\`\`

### http.put(url, body, options)

Make a PUT request. Automatically stringifies objects to JSON.

**Parameters:**
- \`url\` (string) - URL to request
- \`body\` (any) - Request body
- \`options\` (object, optional) - Additional fetch options

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
await http.put('https://api.example.com/users/123', {
  name: 'Alice Updated'
});
console.log('User updated');
\`\`\`

### http.delete(url, options)

Make a DELETE request.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Additional fetch options

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
await http.delete('https://api.example.com/users/123');
console.log('User deleted');
\`\`\`

### http.json(url, options)

Make a GET request and parse response as JSON. Throws error on non-2xx status codes.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Fetch options

**Returns:** Promise\\<any\\> - Parsed JSON response

**Throws:** Error with HTTP status if response is not ok

**Example:**
\`\`\`javascript
try {
  const data = await http.json('https://api.example.com/config');
  console.log('Config:', data);
} catch (error) {
  console.error('Failed to fetch:', error.message);
}
\`\`\`

### http.text(url, options)

Make a GET request and get response as text. Throws error on non-2xx status codes.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Fetch options

**Returns:** Promise\\<string\\> - Response text

**Throws:** Error with HTTP status if response is not ok

**Example:**
\`\`\`javascript
const html = await http.text('https://example.com');
console.log('Page length:', html.length);
\`\`\`

## COMPLETE EXAMPLES

### Fetch and save API data

\`\`\`javascript
// Fetch JSON data and save to file
const users = await http.json('https://jsonplaceholder.typicode.com/users');
await fs.writeFile('/home/users.json', JSON.stringify(users, null, 2));
console.log(\`Saved \${users.length} users to file\`);
\`\`\`

### POST with error handling

\`\`\`javascript
try {
  const response = await http.post('https://api.example.com/submit', {
    message: 'Hello from Koma!'
  });

  if (response.ok) {
    const result = await response.json();
    console.log('Success:', result);
  } else {
    console.error(\`HTTP \${response.status}: \${response.statusText}\`);
  }
} catch (error) {
  console.error('Request failed:', error.message);
}
\`\`\`

### Custom headers

\`\`\`javascript
const response = await http.get('https://api.example.com/protected', {
  headers: {
    'Authorization': 'Bearer my-token',
    'X-Custom-Header': 'value'
  }
});
const data = await response.json();
\`\`\`

## NOTES

- All HTTP requests are subject to CORS restrictions
- The \`json()\` and \`text()\` convenience methods automatically check response.ok
- Objects passed to \`post()\` and \`put()\` are automatically JSON stringified
- For file uploads or other binary data, use \`fetch()\` directly with FormData

## SEE ALSO

run(1), fs(3), cron(1)
`,

  'notify.3.md': `# NAME

notify - browser notifications API for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'notify' module
await notify.send('Task Complete', 'Your script has finished running');
await notify.error('Error', 'Something went wrong');
const hasPermission = notify.permission() === 'granted';
\`\`\`

## DESCRIPTION

The \`notify\` module provides access to browser notifications from JavaScript scripts. Notifications can alert users to events even when Koma is running in a background tab.

**Note:** Currently only available from the main UI context. Scripts running in the Olivine worker cannot directly create notifications but this module is included for future use.

## FUNCTIONS

### notify.isSupported()

Check if the browser supports notifications.

**Returns:** boolean - True if notifications are supported

**Example:**
\`\`\`javascript
if (notify.isSupported()) {
  console.log('Notifications available');
} else {
  console.log('Notifications not supported');
}
\`\`\`

### notify.permission()

Get the current notification permission status.

**Returns:** string - One of:
- \`'granted'\` - User has granted permission
- \`'denied'\` - User has denied permission
- \`'default'\` - Permission not yet requested

**Example:**
\`\`\`javascript
const status = notify.permission();
if (status === 'granted') {
  console.log('Can send notifications');
} else if (status === 'denied') {
  console.log('Notifications blocked');
} else {
  console.log('Need to request permission');
}
\`\`\`

### notify.requestPermission()

Request notification permission from the user. Browser will show a permission prompt.

**Returns:** Promise\\<string\\> - Permission result ('granted' or 'denied')

**Throws:** Error if notifications not supported

**Example:**
\`\`\`javascript
const permission = await notify.requestPermission();
if (permission === 'granted') {
  console.log('Permission granted!');
} else {
  console.log('Permission denied');
}
\`\`\`

### notify.notify(title, options)

Show a notification with custom options.

**Parameters:**
- \`title\` (string) - Notification title
- \`options\` (object, optional) - Notification options:
  - \`body\` (string) - Notification body text
  - \`icon\` (string) - Icon URL (defaults to /favicon.ico)
  - \`tag\` (string) - Notification tag for grouping
  - \`requireInteraction\` (boolean) - Keep notification until user interacts
  - \`silent\` (boolean) - Suppress notification sound

**Returns:** Promise\\<Notification\\> - Notification object

**Throws:** Error if permission not granted or not supported

**Example:**
\`\`\`javascript
await notify.notify('Build Complete', {
  body: 'Your project built successfully',
  icon: '/icons/success.png',
  tag: 'build',
  requireInteraction: false
});
\`\`\`

### notify.send(title, body)

Show a simple notification with title and body text. Automatically requests permission if needed.

**Parameters:**
- \`title\` (string) - Notification title
- \`body\` (string, optional) - Notification body text

**Returns:** Promise\\<Notification\\> - Notification object

**Example:**
\`\`\`javascript
await notify.send('Task Complete', 'The task finished successfully');
\`\`\`

### notify.error(title, body)

Show an error notification. Stays visible until user dismisses it.

**Parameters:**
- \`title\` (string) - Error title
- \`body\` (string, optional) - Error message

**Returns:** Promise\\<Notification\\> - Notification object

**Example:**
\`\`\`javascript
await notify.error('Script Failed', 'Failed to connect to API');
\`\`\`

### notify.success(title, body)

Show a success notification.

**Parameters:**
- \`title\` (string) - Success title
- \`body\` (string, optional) - Success message

**Returns:** Promise\\<Notification\\> - Notification object

**Example:**
\`\`\`javascript
await notify.success('Upload Complete', 'File uploaded successfully');
\`\`\`

## COMPLETE EXAMPLES

### Long-running task notification

\`\`\`javascript
// Notify when a long task completes
console.log('Starting long task...');

try {
  // Do some work...
  const result = await http.json('https://api.example.com/process');

  // Notify success
  await notify.success('Task Complete', \`Processed \${result.count} items\`);
} catch (error) {
  // Notify error
  await notify.error('Task Failed', error.message);
}
\`\`\`

### Permission check before notifying

\`\`\`javascript
// Check permission before attempting notification
if (notify.permission() === 'granted') {
  await notify.send('Hello', 'Notification ready to go');
} else if (notify.permission() === 'default') {
  const permission = await notify.requestPermission();
  if (permission === 'granted') {
    await notify.send('Hello', 'Thanks for granting permission');
  }
} else {
  console.log('Notifications are blocked');
}
\`\`\`

### Cron job notification

\`\`\`javascript
// In a cron script that runs periodically
const stats = await fs.stat('/home/data.txt');
const sizeInMB = (stats.size / 1024 / 1024).toFixed(2);

if (stats.size > 10 * 1024 * 1024) {
  await notify.send(
    'Large File Warning',
    \`data.txt is \${sizeInMB} MB\`
  );
}
\`\`\`

## NOTES

- Notifications require user permission - always check or request permission first
- Browser may rate-limit notifications if too many are shown
- Notifications tagged with the same \`tag\` will replace previous notifications
- Use \`requireInteraction: true\` for critical notifications that need user attention
- Currently only functional in UI context; worker context support planned

## SEE ALSO

run(1), cron(1), http(3)
`,

  'path.3.md': `# NAME

path - POSIX path manipulation utilities for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'path' module
const fullPath = path.join('/home', 'user', 'file.txt');
const dir = path.dirname('/home/user/file.txt');
const file = path.basename('/home/user/file.txt');
const ext = path.extname('file.txt');
\`\`\`

## DESCRIPTION

The \`path\` module provides utilities for working with file paths in a POSIX-style virtual filesystem. All functions work synchronously and use forward slashes (/) as the path separator.

## CONSTANTS

### path.sep

Path separator character. Always \`'/'\` in Koma's POSIX filesystem.

**Example:**
\`\`\`javascript
console.log(path.sep); // '/'
\`\`\`

## FUNCTIONS

### path.join(...segments)

Join path segments into a single normalized path.

**Parameters:**
- \`...segments\` (string) - Path segments to join

**Returns:** string - Joined and normalized path

**Example:**
\`\`\`javascript
path.join('/home', 'user', 'file.txt');  // '/home/user/file.txt'
path.join('/home', '../etc');            // '/etc'
path.join('foo', 'bar', 'baz');          // 'foo/bar/baz'
path.join('/home/', '/', 'user');        // '/home/user'
\`\`\`

### path.resolve(...segments)

Resolve path segments to an absolute path. Processes segments from right to left until an absolute path is constructed.

**Parameters:**
- \`...segments\` (string) - Path segments to resolve

**Returns:** string - Absolute path

**Example:**
\`\`\`javascript
path.resolve('/home', 'user', 'file.txt');  // '/home/user/file.txt'
path.resolve('user', 'file.txt');           // '/user/file.txt'
path.resolve('/foo', '/bar', 'baz');        // '/bar/baz'
\`\`\`

### path.dirname(path)

Get the directory portion of a path.

**Parameters:**
- \`path\` (string) - Path to process

**Returns:** string - Directory name

**Example:**
\`\`\`javascript
path.dirname('/home/user/file.txt');  // '/home/user'
path.dirname('/home/user/');          // '/home'
path.dirname('/home');                // '/'
path.dirname('/');                    // '/'
path.dirname('file.txt');             // '.'
\`\`\`

### path.basename(path, ext)

Get the filename portion of a path. Optionally removes a file extension.

**Parameters:**
- \`path\` (string) - Path to process
- \`ext\` (string, optional) - Extension to remove (including dot)

**Returns:** string - Base filename

**Example:**
\`\`\`javascript
path.basename('/home/user/file.txt');        // 'file.txt'
path.basename('/home/user/file.txt', '.txt'); // 'file'
path.basename('/home/user/');                // 'user'
path.basename('file.txt');                   // 'file.txt'
\`\`\`

### path.extname(path)

Get the file extension from a path, including the leading dot.

**Parameters:**
- \`path\` (string) - Path to process

**Returns:** string - File extension (including dot), or empty string if no extension

**Example:**
\`\`\`javascript
path.extname('/home/user/file.txt');    // '.txt'
path.extname('/home/user/file.tar.gz'); // '.gz'
path.extname('/home/user/file');        // ''
path.extname('/home/user/.bashrc');     // ''
path.extname('file.');                  // ''
\`\`\`

### path.normalize(path)

Normalize a path by resolving \`.\` and \`..\` segments and removing duplicate slashes.

**Parameters:**
- \`path\` (string) - Path to normalize

**Returns:** string - Normalized path

**Example:**
\`\`\`javascript
path.normalize('/home/user/../admin');   // '/home/admin'
path.normalize('/home/./user');          // '/home/user'
path.normalize('//home///user//');       // '/home/user'
path.normalize('/home/user/..');         // '/home'
path.normalize('foo/../bar');            // 'bar'
\`\`\`

### path.relative(from, to)

Get the relative path from one location to another.

**Parameters:**
- \`from\` (string) - Source path
- \`to\` (string) - Destination path

**Returns:** string - Relative path

**Example:**
\`\`\`javascript
path.relative('/home/user', '/home/admin');      // '../admin'
path.relative('/home/user', '/home/user/docs');  // 'docs'
path.relative('/home/user', '/home/user');       // ''
path.relative('/home/user', '/etc');             // '../../etc'
\`\`\`

### path.isAbsolute(path)

Check if a path is absolute (starts with /).

**Parameters:**
- \`path\` (string) - Path to check

**Returns:** boolean - True if absolute path

**Example:**
\`\`\`javascript
path.isAbsolute('/home/user');  // true
path.isAbsolute('user/docs');   // false
path.isAbsolute('../foo');      // false
path.isAbsolute('/');           // true
\`\`\`

## COMPLETE EXAMPLES

### Build output path from components

\`\`\`javascript
const projectDir = '/home/projects/myapp';
const buildDir = 'dist';
const filename = 'bundle.js';

const outputPath = path.join(projectDir, buildDir, filename);
console.log(outputPath); // '/home/projects/myapp/dist/bundle.js'
\`\`\`

### Parse file path information

\`\`\`javascript
const filePath = '/home/user/documents/report.pdf';

const dir = path.dirname(filePath);      // '/home/user/documents'
const file = path.basename(filePath);    // 'report.pdf'
const name = path.basename(filePath, path.extname(filePath)); // 'report'
const ext = path.extname(filePath);      // '.pdf'

console.log(\`Directory: \${dir}\`);
console.log(\`Filename: \${file}\`);
console.log(\`Name: \${name}\`);
console.log(\`Extension: \${ext}\`);
\`\`\`

### Resolve relative imports

\`\`\`javascript
// Resolve a relative import from current file
const currentFile = '/home/projects/src/components/button.js';
const importPath = '../utils/helpers.js';

const currentDir = path.dirname(currentFile);
const resolvedPath = path.resolve(currentDir, importPath);

console.log(resolvedPath); // '/home/projects/src/utils/helpers.js'
\`\`\`

### File operations with path utilities

\`\`\`javascript
// Build paths for file operations
const baseDir = env.HOME;
const configFile = path.join(baseDir, 'config', 'app.json');

// Check if config exists
if (await fs.exists(configFile)) {
  const content = await fs.readFile(configFile);
  console.log('Config loaded from:', configFile);
} else {
  // Create config directory if needed
  const configDir = path.dirname(configFile);
  await fs.mkdir(configDir);

  // Create default config
  await fs.writeFile(configFile, '{}');
  console.log('Created config at:', configFile);
}
\`\`\`

### Calculate relative paths for links

\`\`\`javascript
// Generate relative path for file references
const pageFile = '/home/projects/docs/pages/about.html';
const cssFile = '/home/projects/docs/styles/main.css';

const relativePath = path.relative(
  path.dirname(pageFile),
  cssFile
);

console.log(\`<link href="\${relativePath}">\`);
// <link href="../styles/main.css">
\`\`\`

## NOTES

- All paths use forward slash (/) as separator (POSIX style)
- Absolute paths start with /
- \`.\` represents current directory
- \`..\` represents parent directory
- Multiple consecutive slashes are treated as a single slash
- Trailing slashes are generally ignored
- Empty path returns \`'.'\` (current directory)

## SEE ALSO

fs(3), cd(1), pwd(1), ls(1)
`

};
