/**
 * Man Pages Content
 * Auto-generated by build-man-pages.py
 * DO NOT EDIT - Edit files in docs/man/ instead
 */

export const manPages = {
  'backup.1.md': `# backup(1) - Koma Manual

## NAME
backup - create VFS backup in Koma Magnetic Tape format

## SYNOPSIS
**backup** [*label*] [**--no-compress**]

## DESCRIPTION
Creates a compressed backup of the entire Virtual File System (VFS) and downloads it as a **.kmt** (Koma Magnetic Tape) file. The backup includes all files, directories, and metadata, excluding the \`/mnt/backups/\` directory.

Backups use **gzip compression** by default (typically achieving 70-85% size reduction) and include **dual SHA-256 checksums** for integrity verification.

## OPTIONS
**label**
: Optional label for the backup. Used in the filename. Default: "backup"

**--no-compress**
: Disable gzip compression. Creates larger but faster backups.

## FILE FORMAT
The .kmt format is a JSON file containing:

- **format**: "kmt" (Koma Magnetic Tape)
- **version**: Format version (currently "1.0")
- **created**: ISO 8601 timestamp
- **label**: User-provided label
- **compression**: "gzip" or "none"
- **checksum**: Dual hashes (uncompressed and compressed data)
- **stats**: File/directory counts and sizes
- **data**: Base64-encoded (and optionally compressed) VFS entries

## EXAMPLES
Create a compressed backup:
\`\`\`bash
backup
\`\`\`

Create a labeled backup:
\`\`\`bash
backup project-v1
\`\`\`

Create an uncompressed backup:
\`\`\`bash
backup debug --no-compress
\`\`\`

## OUTPUT
The backup file is downloaded to your browser's Downloads folder with the format:
\`\`\`
backup-YYYYMMDD-HHMMSS-label.kmt
\`\`\`

The command displays:
- Number of files and directories
- Compressed and uncompressed sizes
- Compression ratio
- Checksum (first 16 characters)

## TAPE METAPHOR
The .kmt format follows the aesthetic of Unix magnetic tape archives:
- Sequential access (entire archive compressed as one unit)
- Write-once semantics
- Integrity verification through checksums
- Suitable for long-term storage

## FILES
**/mnt/backups/**
: Directory excluded from backups (to avoid backup loops)

## SEE ALSO
**restore**(1), **tar**(1), **cpio**(1)

## NOTES
- Binary files are handled correctly
- Timestamps are preserved
- The compression uses the browser's native CompressionStream API
- No external libraries required

## COMPRESSION DETAILS
Backup compresses the entire VFS entries array as a single unit using gzip. This approach:
- Achieves better compression than per-file compression
- Matches authentic tape semantics
- Simplifies the implementation
- Allows faster decompression

Typical compression ratios:
- Text files: 80-90% reduction
- Mixed content: 70-85% reduction
- Binary files: 50-70% reduction

## EXAMPLES OF USE
**Daily backup:**
\`\`\`bash
backup daily-$(date +%Y%m%d)
\`\`\`

**Pre-deployment snapshot:**
\`\`\`bash
backup pre-deploy
# Make changes
# If something breaks: restore pre-deploy.kmt --now
\`\`\`

**Testing setup:**
\`\`\`bash
backup clean-state
# Run tests
restore clean-state.kmt --now
# Run more tests with clean state
\`\`\`

## HISTORY
The backup/restore system was added in Koma v0.5.6 to provide:
1. VFS snapshot capability for testing
2. User data backup functionality
3. A retro-aesthetic tape backup experience

## AUTHOR
Koma Terminal Project
`,

  'cat.1.md': `# NAME

cat - concatenate and display files

## SYNOPSIS

\`cat <file>\`

## DESCRIPTION

Read files and write their contents to the terminal. Displays the complete file contents.

## EXAMPLES

Display a file:
\`\`\`
cat file.txt
\`\`\`

Display a script:
\`\`\`
cat /home/hello.js
\`\`\`

## SEE ALSO

head(1), tail(1), vein(1)
`,

  'cd.1.md': `# NAME

cd - change directory

## SYNOPSIS

\`cd [directory]\`

## DESCRIPTION

Change the current working directory. If no directory is specified, changes to the home directory (/home).

Special paths:
- **~** - Home directory (/home)
- **..** - Parent directory
- **/** - Root directory

## EXAMPLES

Change to home:
\`\`\`
cd
cd ~
\`\`\`

Change to parent:
\`\`\`
cd ..
\`\`\`

Change to absolute path:
\`\`\`
cd /usr/bin
\`\`\`

Change to relative path:
\`\`\`
cd projects
\`\`\`

## SEE ALSO

pwd(1), ls(1)
`,

  'cp.1.md': `# NAME

cp - copy files

## SYNOPSIS

\`cp <source> <destination>\`

## DESCRIPTION

Copy a file to a new location. If the destination is a directory, the file is copied into it. Otherwise, creates a new file with the destination name.

Currently only supports copying files, not directories.

## EXAMPLES

Copy a file:
\`\`\`
cp file.txt backup.txt
\`\`\`

Copy into a directory:
\`\`\`
cp script.js /usr/bin/
\`\`\`

Copy with absolute paths:
\`\`\`
cp /home/config.json /tmp/config.json
\`\`\`

## SEE ALSO

mv(1), rm(1), cat(1)
`,

  'find.1.md': `# NAME

find - search for files in directory hierarchy

## SYNOPSIS

\`\`\`bash
find [path]
find [path] -name <pattern>
find [path] -type <f|d>
find [path] -name <pattern> -type <f|d>
\`\`\`

## DESCRIPTION

The \`find\` command recursively searches directories for files matching specified criteria. It can filter by filename pattern and file type.

If no path is specified, \`find\` searches the current directory and all subdirectories.

## OPTIONS

### -name, -n PATTERN

Match files by name pattern. Supports wildcards:
- \`*\` - Matches any sequence of characters
- \`?\` - Matches any single character

Patterns are case-sensitive and match against the filename only, not the full path.

### -type, -t TYPE

Filter by file type:
- \`f\` - Regular files only
- \`d\` - Directories only

## EXAMPLES

List all files under \`/home\`:
\`\`\`bash
find /home
\`\`\`

Find all text files in current directory:
\`\`\`bash
find -name "*.txt"
\`\`\`

Find all JavaScript files:
\`\`\`bash
find -name "*.js" -type f
\`\`\`

Find all directories:
\`\`\`bash
find -type d
\`\`\`

Find config files:
\`\`\`bash
find /home -name "*config*"
\`\`\`

## USAGE WITH PIPES

\`find\` works well with pipes for further filtering:

\`\`\`bash
# Find and count JavaScript files
find -name "*.js" | wc -l

# Find and display sorted
find /home -name "*.txt" | sort

# Find and grep through results
find -name "*.js" | grep test
\`\`\`

## NOTES

- Searches recursively through all subdirectories
- Silently skips directories that cannot be read
- Results are output as full paths
- Patterns match filename only, not the full path
- Case-sensitive pattern matching

## SEE ALSO

ls(1), grep(1), stat(1)
`,

  'grep.1.md': `# NAME

grep - search for patterns in files or input

## SYNOPSIS

\`\`\`bash
grep [options] <pattern> [file]
grep -n <pattern> <file>
grep -i <pattern> <file>
grep -v <pattern> <file>
grep -c <pattern> <file>
command | grep <pattern>
\`\`\`

## DESCRIPTION

The \`grep\` command searches for lines matching a pattern (regular expression) in files or standard input. It outputs matching lines to standard output.

When reading from a file, grep searches the specified file. When used in a pipeline, grep reads from standard input.

By default, grep performs case-sensitive matching and outputs only the matching lines without modification.

## OPTIONS

### -n, --number

Prefix each output line with its line number in the input.

**Example:**
\`\`\`bash
grep -n error log.txt
\`\`\`

Output:
\`\`\`
5:error: file not found
12:error: connection timeout
\`\`\`

### -i, --ignore-case

Perform case-insensitive pattern matching. By default, grep is case-sensitive.

**Example:**
\`\`\`bash
grep -i error log.txt
\`\`\`

Matches "error", "Error", "ERROR", "ErRoR", etc.

### -v, --invert

Invert the match - output lines that do NOT match the pattern.

**Example:**
\`\`\`bash
grep -v comment config.txt
\`\`\`

Shows all lines that don't contain "comment".

### -c, --count

Suppress normal output and only print the count of matching lines.

**Example:**
\`\`\`bash
grep -c error log.txt
\`\`\`

Output:
\`\`\`
42
\`\`\`

## PATTERN SYNTAX

Grep uses JavaScript regular expressions. Common patterns:

- \`.\` - Match any single character
- \`*\` - Match zero or more of the preceding character
- \`+\` - Match one or more of the preceding character
- \`^\` - Match start of line
- \`$\` - Match end of line
- \`[abc]\` - Match any character in brackets
- \`[^abc]\` - Match any character NOT in brackets
- \`\\d\` - Match any digit
- \`\\w\` - Match any word character
- \`\\s\` - Match any whitespace

**Examples:**
\`\`\`bash
grep "^import"           # Lines starting with "import"
grep "error$"            # Lines ending with "error"
grep "test.*file"        # "test" followed by "file"
grep "[0-9]+"            # Lines containing numbers
\`\`\`

## EXAMPLES

### Basic search

Search for "error" in log file:
\`\`\`bash
grep error log.txt
\`\`\`

### With line numbers

Show line numbers for matches:
\`\`\`bash
grep -n TODO script.js
\`\`\`

### Case-insensitive search

Find "error" regardless of case:
\`\`\`bash
grep -i error log.txt
\`\`\`

### Count matches

Count how many lines contain "error":
\`\`\`bash
grep -c error log.txt
\`\`\`

### Invert match

Show lines that don't contain comments:
\`\`\`bash
grep -v "^#" config.sh
\`\`\`

### Pipeline usage

Search through piped input:
\`\`\`bash
cat log.txt | grep error
ls | grep ".txt"
find /home -name "*.js" | grep test
\`\`\`

### Combined flags

Show line numbers with case-insensitive search:
\`\`\`bash
grep -ni error log.txt
\`\`\`

Count non-matching lines:
\`\`\`bash
grep -vc "^#" config.sh
\`\`\`

### Regular expressions

Find lines starting with "import":
\`\`\`bash
grep "^import" script.js
\`\`\`

Find lines with numbers:
\`\`\`bash
grep "[0-9]" data.txt
\`\`\`

Find email-like patterns:
\`\`\`bash
grep "\\w+@\\w+\\.\\w+" contacts.txt
\`\`\`

## OUTPUT FORMAT

### Default output

Just the matching lines:
\`\`\`
error in file.txt
another error occurred
\`\`\`

### With -n (line numbers)

Line numbers prefixed with colon:
\`\`\`
5:error in file.txt
12:another error occurred
\`\`\`

### With -c (count)

Just the number:
\`\`\`
2
\`\`\`

### Terminal output

When outputting directly to terminal (not piped), matching text is highlighted in red for easier visibility.

When piped to another command, no color formatting is applied.

## USAGE WITH PIPES

Grep is commonly used in pipelines:

\`\`\`bash
# Find and filter
find /home -name "*.txt" | grep config

# Multiple filters
cat log.txt | grep error | grep -v warning

# Count matches in pipeline
ls | grep ".js" | grep -c test

# Process output
grep error log.txt | sort | uniq
\`\`\`

## EXIT STATUS

Grep returns:
- **0** - One or more lines matched
- **Error** - If an error occurred (file not found, etc.)

## NOTES

- Patterns are JavaScript regular expressions
- Case-sensitive by default (use \`-i\` for case-insensitive)
- Empty pattern matches all lines
- Reads from stdin when no file specified (useful in pipes)
- Color highlighting only appears in terminal, not in pipes
- Multiple flags can be combined: \`-ni\`, \`-cv\`, etc.

## SEE ALSO

cat(1), find(1), sort(1), uniq(1), head(1), tail(1), wc(1)
`,

  'head.1.md': `# NAME

head - display first lines of file

## SYNOPSIS

\`head <file> [-n lines]\`

## DESCRIPTION

Display the first 10 lines of a file. Use the -n option to specify a different number of lines.

## OPTIONS

**-n NUM**
  Display NUM lines instead of the default 10.

## EXAMPLES

Show first 10 lines:
\`\`\`
head log.txt
\`\`\`

Show first 5 lines:
\`\`\`
head -n 5 log.txt
\`\`\`

Show first 20 lines:
\`\`\`
head -n 20 /home/script.js
\`\`\`

## SEE ALSO

tail(1), cat(1), grep(1), wc(1)
`,

  'ls.1.md': `# NAME

ls - list directory contents

## SYNOPSIS

\`ls [options] [path]\`

## DESCRIPTION

List information about files and directories. By default, lists the current working directory.

## OPTIONS

**-l**
  Use long listing format, showing permissions, size, and modification date.

## EXAMPLES

List current directory:
\`\`\`
ls
\`\`\`

List with details:
\`\`\`
ls -l
\`\`\`

List specific directory:
\`\`\`
ls /usr/bin
\`\`\`

## SEE ALSO

cd(1), tree(1), pwd(1)
`,

  'mkdir.1.md': `# NAME

mkdir - create directories

## SYNOPSIS

\`mkdir <directory> [directories...]\`

## DESCRIPTION

Create one or more directories in the virtual filesystem. Parent directories must exist (no recursive creation).

## EXAMPLES

Create a directory:
\`\`\`
mkdir projects
\`\`\`

Create multiple directories:
\`\`\`
mkdir docs logs temp
\`\`\`

Create in absolute path:
\`\`\`
mkdir /home/workspace
\`\`\`

## SEE ALSO

rm(1), touch(1), ls(1)
`,

  'mv.1.md': `# NAME

mv - move or rename files and directories

## SYNOPSIS

\`mv <source> <destination>\`

## DESCRIPTION

Move or rename files and directories. If the destination is a directory, the source is moved into it. Otherwise, the source is renamed to the destination name.

Works with both files and directories.

## EXAMPLES

Rename a file:
\`\`\`
mv old-name.txt new-name.txt
\`\`\`

Move into directory:
\`\`\`
mv file.txt /home/documents/
\`\`\`

Rename a directory:
\`\`\`
mv old-dir new-dir
\`\`\`

Move directory:
\`\`\`
mv /tmp/cache /home/backup/
\`\`\`

## SEE ALSO

cp(1), rm(1), cd(1)
`,

  'pwd.1.md': `# NAME

pwd - print working directory

## SYNOPSIS

\`pwd\`

## DESCRIPTION

Display the absolute path of the current working directory.

## EXAMPLES

Show current directory:
\`\`\`
pwd
\`\`\`

## SEE ALSO

cd(1), ls(1)
`,

  'restore.1.md': `# restore(1) - Koma Manual

## NAME
restore - restore VFS from Koma Magnetic Tape backup

## SYNOPSIS
**restore** *file* [**--apply** | **--now**]

## DESCRIPTION
Restores the Virtual File System (VFS) from a **.kmt** (Koma Magnetic Tape) backup file. The restore process has two modes:

1. **Verify and stage** (default): Verifies backup integrity and saves it to \`/mnt/backups/\`
2. **Apply**: Restores VFS from a staged backup

The restore process includes:
- Dual checksum verification (compressed and uncompressed)
- Metadata display
- VFS clearing (except \`/mnt/backups/\`)
- Complete restoration of all files and directories

## OPTIONS
**file**
: Backup file to restore. Can be:
  - Just the filename (looks in \`/mnt/backups/\`)
  - Full path (e.g., \`/mnt/backups/backup.kmt\`)

**--apply**
: Apply a previously staged backup. Reads from \`/mnt/backups/\`.

**--now**
: Verify and apply immediately, skipping the staging step.

## WORKFLOW

### Three-Step Restore (Safest)
\`\`\`bash
# Step 1: Upload and verify
restore backup.kmt
# Shows: verification, metadata, staging location

# Step 2: Apply
restore backup.kmt --apply
# Clears VFS and restores backup
\`\`\`

### One-Step Restore (Fastest)
\`\`\`bash
restore backup.kmt --now
# Verifies and applies immediately
\`\`\`

## VERIFICATION
The restore command performs comprehensive verification:

1. **Format check**: Ensures file is a valid .kmt backup
2. **Compressed hash**: Verifies file wasn't corrupted during transfer
3. **Decompression**: Extracts the backup data
4. **Uncompressed hash**: Verifies data integrity after decompression

If any verification fails, the restore is aborted with an error message.

## METADATA DISPLAY
Upon successful verification, restore shows:

\`\`\`
✓ Backup verified

  Format: kmt v1.0
  Created: 2025-11-10T18:30:00Z
  Label: project-v1
  Files: 254
  Directories: 12
  Size: 412.8 KB (compressed)
  Compression: 84.2%
  Checksum: ✓ Valid
\`\`\`

## APPLY PROCESS
When applying a backup (**--apply** or **--now**):

1. **Clear VFS**: All existing files are deleted (except \`/mnt/backups/\`)
2. **Restore directories**: Creates directory structure
3. **Restore files**: Writes all files with original content and metadata
4. **Completion**: Displays success message

**Warning**: This operation is destructive! All current VFS data (except backups) is lost.

## FILE INPUT
When running \`restore\` without **--apply**, a file picker dialog opens to select the .kmt file from your computer.

## EXAMPLES
Verify and stage a backup:
\`\`\`bash
restore backup.kmt
\`\`\`

Apply a staged backup:
\`\`\`bash
restore backup.kmt --apply
\`\`\`

Verify and apply immediately:
\`\`\`bash
restore backup.kmt --now
\`\`\`

Restore from a specific path:
\`\`\`bash
restore /mnt/backups/backup-20251110-project-v1.kmt --apply
\`\`\`

## TESTING USE CASE
The backup/restore system is ideal for testing:

\`\`\`bash
# Create a clean state snapshot
backup clean-state

# Run tests that modify VFS
sh run-tests.sh

# Restore clean state
restore clean-state.kmt --now

# Run more tests
sh more-tests.sh
\`\`\`

## FILES
**/mnt/backups/**
: Directory where staged backups are saved. This directory is preserved during restore operations.

## SAFETY
- **Staged backups** are safer: allows review before applying
- **Immediate restore** (**--now**) is faster but riskier
- **Checksums** protect against corrupted backups
- **/mnt/backups/** directory is never deleted

## ERROR MESSAGES
**error: invalid backup format**
: File is not a valid .kmt backup

**error: backup file is corrupted (compressed hash mismatch)**
: File was corrupted during download/storage

**error: backup data is corrupted (uncompressed hash mismatch)**
: Data is corrupted after decompression

**error: missing backup file**
: No filename provided

## COMPRESSION SUPPORT
Restore automatically detects and handles:
- Gzip-compressed backups (default from \`backup\` command)
- Uncompressed backups (created with \`backup --no-compress\`)

No flags needed - the .kmt format specifies the compression method.

## BINARY FILES
Restore correctly handles all file types:
- Text files (UTF-8)
- Binary files (images, PDFs, etc.)
- Files with special characters
- Empty files

## TAPE METAPHOR
Like traditional Unix tape restore:
- Reads sequentially (entire archive decompressed as one unit)
- Verifies checksums (tape data integrity)
- Restores complete snapshots
- Preserves timestamps and metadata

## PERFORMANCE
Typical restore times on modern hardware:
- Small VFS (< 1 MB): < 1 second
- Medium VFS (1-10 MB): 1-3 seconds
- Large VFS (10-100 MB): 3-10 seconds

Verification adds minimal overhead (< 100ms for most backups).

## SEE ALSO
**backup**(1), **tar**(1), **cpio**(1), **restore**(8)

## NOTES
- The file picker dialog is a browser limitation - cannot read files directly from command line
- **--apply** mode reads from VFS, so no file picker is needed
- Timestamps are preserved from the original files
- The \`/mnt/backups/\` directory is automatically created if needed

## EXAMPLES OF USE
**Test isolation:**
\`\`\`bash
# Each test gets clean state
restore fixtures.kmt --now
run_test_1
restore fixtures.kmt --now
run_test_2
\`\`\`

**Disaster recovery:**
\`\`\`bash
# Upload backup
restore system-backup.kmt

# Review metadata
# Confirm it's the right backup

# Apply
restore system-backup.kmt --apply
\`\`\`

**Version rollback:**
\`\`\`bash
# Backup current state
backup current-state

# Try experimental changes
make_changes

# If it breaks, restore previous state
restore current-state.kmt --now
\`\`\`

## HISTORY
The backup/restore system was added in Koma v0.5.6 to provide:
1. VFS snapshot capability for testing
2. User data backup/recovery functionality
3. A retro-aesthetic tape restore experience

## AUTHOR
Koma Terminal Project
`,

  'rm.1.md': `# NAME

rm - remove files and directories

## SYNOPSIS

\`rm <path> [paths...]\`

## DESCRIPTION

Delete one or more files or directories from the virtual filesystem. Directories are removed recursively.

**Warning:** This operation is permanent and cannot be undone.

## EXAMPLES

Remove a file:
\`\`\`
rm old-file.txt
\`\`\`

Remove multiple files:
\`\`\`
rm file1.txt file2.txt temp.log
\`\`\`

Remove a directory:
\`\`\`
rm /tmp/cache
\`\`\`

## SEE ALSO

mkdir(1), touch(1), cp(1), mv(1)
`,

  'sort.1.md': `# NAME

sort - sort lines of text files

## SYNOPSIS

\`\`\`bash
sort [file]
sort -r [file]
sort -n [file]
command | sort
\`\`\`

## DESCRIPTION

The \`sort\` command sorts lines of text alphabetically or numerically. It can read from a file or from standard input (piped data).

By default, \`sort\` performs case-sensitive lexicographic sorting.

## OPTIONS

### -r, --reverse

Reverse the sort order (descending instead of ascending).

### -n, --numeric

Sort numerically instead of alphabetically. This treats lines as numbers and sorts them by numeric value.

## EXAMPLES

Sort lines in a file:
\`\`\`bash
sort names.txt
\`\`\`

Sort directory listing:
\`\`\`bash
ls | sort
\`\`\`

Reverse sort:
\`\`\`bash
sort -r file.txt
\`\`\`

Sort numbers correctly:
\`\`\`bash
sort -n numbers.txt
\`\`\`

Sort and save to file:
\`\`\`bash
sort names.txt > sorted.txt
\`\`\`

## USAGE WITH PIPES

\`sort\` is commonly used in pipelines:

\`\`\`bash
# Sort and remove duplicates
sort file.txt | uniq

# Find unique extensions
ls | sort | uniq

# Sort and show first 10
cat file.txt | sort | head

# Reverse sort with grep
grep error log.txt | sort -r
\`\`\`

## NOTES

- Case-sensitive by default
- Empty lines are sorted to the beginning
- Without \`-n\`, numbers are sorted lexicographically: "10" < "2"
- With \`-n\`, numbers are sorted numerically: 2 < 10
- Reads from stdin if no file specified
- Output can be piped or redirected

## SEE ALSO

uniq(1), grep(1), cat(1)
`,

  'stat.1.md': `# NAME

stat - display file status

## SYNOPSIS

\`stat <file>\`

## DESCRIPTION

Display detailed information about a file or directory, including:
- File type (file or directory)
- Size in bytes
- Inode number
- Timestamps (created, modified, accessed)
- Permissions

## EXAMPLES

Show file information:
\`\`\`
stat file.txt
\`\`\`

Show directory information:
\`\`\`
stat /home
\`\`\`

Check script details:
\`\`\`
stat /usr/bin/script.js
\`\`\`

## SEE ALSO

ls(1), wc(1), cat(1)
`,

  'tail.1.md': `# NAME

tail - display last lines of file

## SYNOPSIS

\`tail <file> [-n lines]\`

## DESCRIPTION

Display the last 10 lines of a file. Use the -n option to specify a different number of lines.

## OPTIONS

**-n NUM**
  Display NUM lines instead of the default 10.

## EXAMPLES

Show last 10 lines:
\`\`\`
tail log.txt
\`\`\`

Show last 5 lines:
\`\`\`
tail -n 5 log.txt
\`\`\`

Show last 20 lines:
\`\`\`
tail -n 20 /home/output.log
\`\`\`

## SEE ALSO

head(1), cat(1), grep(1), wc(1)
`,

  'tee.1.md': `# NAME

tee - read from stdin and write to file and stdout

## SYNOPSIS

\`\`\`bash
command | tee <file>
command | tee -a <file>
command | tee <file1> <file2> <file3>
\`\`\`

## DESCRIPTION

The \`tee\` command reads from standard input and writes to both standard output and one or more files simultaneously. This allows you to save command output to a file while still viewing it in the terminal or passing it to the next command in a pipeline.

Think of it like a "T-junction" in plumbing - the data flows in one direction and splits into two.

## OPTIONS

### -a, --append

Append to the file(s) instead of overwriting them. If the file doesn't exist, it will be created.

## EXAMPLES

### Basic usage

Save ls output to a file and view it:
\`\`\`bash
ls | tee output.txt
\`\`\`

### Pipeline with tee

Save intermediate results in a pipeline:
\`\`\`bash
cat log.txt | grep error | tee errors.txt | wc -l
\`\`\`

This:
1. Searches for "error" in log.txt
2. Saves results to errors.txt
3. Counts the lines
4. Shows both the saved lines AND the count

### Append mode

Add to an existing log file:
\`\`\`bash
echo "New log entry" | tee -a log.txt
\`\`\`

### Multiple files

Write to multiple files at once:
\`\`\`bash
ls | tee file1.txt file2.txt file3.txt
\`\`\`

All three files get the same content.

### Complex pipeline

Monitor and log a process:
\`\`\`bash
find /home -name "*.txt" | tee found-files.txt | wc -l
\`\`\`

This shows how many .txt files were found AND saves the list.

### Building logs

Append timestamped entries:
\`\`\`bash
echo "$(date): System check complete" | tee -a system.log
\`\`\`

## COMMON USE CASES

### Save pipeline output for later inspection

\`\`\`bash
ps | grep running | tee snapshot.txt | sort
\`\`\`

You get sorted output in terminal, but also a saved snapshot.

### Debugging pipelines

Insert tee to see intermediate results:
\`\`\`bash
cat data.txt | grep pattern | tee debug.txt | sort | uniq
\`\`\`

Check debug.txt to see what grep found before sort/uniq modified it.

### Logging command output

\`\`\`bash
ls -la | tee directory-listing.txt
\`\`\`

View the listing now, but also have it saved for records.

### Split data to multiple destinations

\`\`\`bash
cat data.txt | tee backup1.txt backup2.txt > /dev/null
\`\`\`

(Note: We don't have /dev/null yet, so just use \`| cat > /dev/null\` to suppress terminal output)

## HOW IT WORKS

\`\`\`
Input (stdin) → tee → Output (stdout)
                  ↓
               File(s)
\`\`\`

Data flows through tee and gets copied to both destinations.

## NOTES

- Requires input from a pipe (cannot read from terminal directly)
- Can write to multiple files in one command
- Without \`-a\`, overwrites existing files
- With \`-a\`, appends to existing files (creates if missing)
- Output to stdout continues to flow for further piping
- Very useful for debugging complex pipelines

## SEE ALSO

cat(1), grep(1), sort(1), wc(1)
`,

  'touch.1.md': `# NAME

touch - create empty files

## SYNOPSIS

\`touch <file> [files...]\`

## DESCRIPTION

Create one or more empty files in the virtual filesystem. If the file already exists, updates its modification timestamp.

## EXAMPLES

Create a file:
\`\`\`
touch README.md
\`\`\`

Create multiple files:
\`\`\`
touch file1.txt file2.txt file3.txt
\`\`\`

Update timestamp:
\`\`\`
touch existing-file.txt
\`\`\`

## SEE ALSO

mkdir(1), rm(1), vein(1), write(1)
`,

  'tree.1.md': `# NAME

tree - display directory tree structure

## SYNOPSIS

\`tree [path]\`

## DESCRIPTION

Display the directory structure as a tree. Shows files and subdirectories in a hierarchical format. If no path is specified, displays the current working directory.

## EXAMPLES

Show current directory tree:
\`\`\`
tree
\`\`\`

Show specific directory:
\`\`\`
tree /usr
\`\`\`

Show home directory tree:
\`\`\`
tree /home
\`\`\`

## SEE ALSO

ls(1), pwd(1), cd(1)
`,

  'uniq.1.md': `# NAME

uniq - report or omit repeated lines

## SYNOPSIS

\`\`\`bash
uniq [file]
uniq -c [file]
command | uniq
\`\`\`

## DESCRIPTION

The \`uniq\` command filters out repeated consecutive lines from input. It compares adjacent lines and removes duplicates, keeping only one copy of each repeated line.

**Important:** \`uniq\` only removes **consecutive** duplicates. To remove all duplicates, sort the input first: \`sort file.txt | uniq\`.

## OPTIONS

### -c, --count

Prefix each line with the number of times it occurred. Output format:
\`\`\`
      3 line1
      1 line2
      2 line3
\`\`\`

Count is right-aligned in a 7-character field.

## EXAMPLES

Remove consecutive duplicates:
\`\`\`bash
uniq file.txt
\`\`\`

Remove all duplicates (sort first):
\`\`\`bash
sort file.txt | uniq
\`\`\`

Count occurrences:
\`\`\`bash
uniq -c file.txt
\`\`\`

Find unique values in data:
\`\`\`bash
cat data.txt | sort | uniq
\`\`\`

Count unique lines and sort by frequency:
\`\`\`bash
sort file.txt | uniq -c | sort -nr
\`\`\`

## USAGE WITH PIPES

\`uniq\` is most useful in pipelines, especially with \`sort\`:

\`\`\`bash
# Get unique lines from file
sort names.txt | uniq

# Count frequency of each line
sort log.txt | uniq -c | sort -nr

# Find duplicate lines
sort file.txt | uniq -c | grep -v "^      1"

# List unique directory contents
ls /home | sort | uniq
\`\`\`

## BEHAVIOR

Input:
\`\`\`
apple
apple
banana
banana
banana
apple
\`\`\`

Output of \`uniq\`:
\`\`\`
apple
banana
apple
\`\`\`

Output of \`sort | uniq\`:
\`\`\`
apple
banana
\`\`\`

Output of \`sort | uniq -c\`:
\`\`\`
      3 apple
      3 banana
\`\`\`

## NOTES

- Only removes **consecutive** duplicates
- For all duplicates, use \`sort\` first: \`sort | uniq\`
- Empty lines are treated as unique lines
- Case-sensitive comparison
- Reads from stdin if no file specified
- Output can be piped or redirected

## SEE ALSO

sort(1), grep(1), wc(1)
`,

  'vein.1.md': `# NAME

vein - text editor

## SYNOPSIS

\`vein <file> [options]\`

## DESCRIPTION

Open files in the CodeMirror text editor. Creates new files if they don't exist. The editor provides a clean interface for editing text files in the virtual filesystem.

## OPTIONS

**-f, --force**
  Open file even if the editor has unsaved changes.

## KEYBOARD SHORTCUTS

**F2 / Ctrl+\`**
  Toggle between terminal and editor

**Ctrl+S**
  Save file

**Esc**
  Close editor (prompts if unsaved changes)

**Ctrl+Z**
  Undo

## EXAMPLES

Edit a file:
\`\`\`
vein file.txt
\`\`\`

Force open:
\`\`\`
vein test.js --force
\`\`\`

Create and edit new file:
\`\`\`
vein /home/notes.md
\`\`\`

## SEE ALSO

cat(1), write(1)
`,

  'wc.1.md': `# NAME

wc - word, line, and byte count

## SYNOPSIS

\`wc <file> [-l] [-w] [-c]\`

## DESCRIPTION

Count lines, words, and bytes in a file. Without options, displays all three counts.

## OPTIONS

**-l**
  Show only line count.

**-w**
  Show only word count.

**-c**
  Show only byte count (character count).

## EXAMPLES

Show all counts:
\`\`\`
wc file.txt
\`\`\`

Count lines only:
\`\`\`
wc -l script.js
\`\`\`

Count words only:
\`\`\`
wc -w document.txt
\`\`\`

## SEE ALSO

cat(1), head(1), tail(1), stat(1)
`,

  'write.1.md': `# NAME

write - write text to file from stdin

## SYNOPSIS

\`write <file>\`

## DESCRIPTION

Write text content to a file. Prompts for input line by line. Enter a blank line to finish and save the file.

Useful for quickly creating files with text content without opening the editor.

## EXAMPLES

Write to a file:
\`\`\`
write notes.txt
\`\`\`

Then type lines of text, pressing Enter after each line. Press Enter on a blank line to finish.

Write to a script:
\`\`\`
write /home/script.js
\`\`\`

## SEE ALSO

vein(1), cat(1), touch(1), echo(1)
`,

  'clear.1.md': `# NAME

clear - clear the terminal screen

## SYNOPSIS

\`clear\`

## DESCRIPTION

Clear the terminal screen and scroll buffer. The prompt is displayed at the top of the terminal.

Also accessible via the Ctrl+L keyboard shortcut.

## EXAMPLES

Clear screen:
\`\`\`
clear
\`\`\`

## SEE ALSO

history(1), help(1)
`,

  'cron.1.md': `# NAME

cron - schedule periodic script execution

## SYNOPSIS

\`cron <schedule> <script>\`

## DESCRIPTION

Schedule a JavaScript file to run periodically based on a cron expression. Jobs continue running across sessions.

## SCHEDULE FORMAT

Five fields: **minute hour day month weekday**

- ***** - Any value (matches all)
- ****/N** - Every N (e.g., */5 = every 5 minutes)
- **N-M** - Range from N to M
- **N,M,P** - List of specific values

Field ranges:
- minute: 0-59
- hour: 0-23
- day: 1-31
- month: 1-12
- weekday: 0-6 (0 = Sunday)

## EXAMPLES

Every 5 minutes:
\`\`\`
cron "*/5 * * * *" /home/backup.js
\`\`\`

Every 2 hours:
\`\`\`
cron "0 */2 * * *" /home/check.js
\`\`\`

9:30 AM on weekdays:
\`\`\`
cron "30 9 * * 1-5" /home/work.js
\`\`\`

First day of each month:
\`\`\`
cron "0 0 1 * *" /home/monthly.js
\`\`\`

## SEE ALSO

cronlist(1), cronrm(1), run(1)
`,

  'cronlist.1.md': `# NAME

cronlist - list scheduled cron jobs

## SYNOPSIS

\`cronlist\`

## DESCRIPTION

Display all scheduled cron jobs with their:
- Job ID (for use with cronrm)
- Cron schedule expression
- Script path
- Next scheduled execution time

Cron jobs persist across page reloads and continue executing in the background.

## EXAMPLES

List all cron jobs:
\`\`\`
cronlist
\`\`\`

## SEE ALSO

cron(1), cronrm(1), ps(1)
`,

  'cronrm.1.md': `# NAME

cronrm - remove scheduled cron job

## SYNOPSIS

\`cronrm <job_id>\`

## DESCRIPTION

Remove a scheduled cron job by its job ID. The job will no longer execute.

Use \`cronlist\` to display all jobs and their IDs.

## EXAMPLES

Remove job with ID 1:
\`\`\`
cronrm 1
\`\`\`

List jobs and remove one:
\`\`\`
cronlist
cronrm 3
\`\`\`

## SEE ALSO

cron(1), cronlist(1), kill(1)
`,

  'echo.1.md': `# NAME

echo - display text

## SYNOPSIS

\`echo [text...]\`

## DESCRIPTION

Display arguments as text to the terminal. Joins all arguments with spaces.

## EXAMPLES

Print a message:
\`\`\`
echo Hello, World!
\`\`\`

Print multiple words:
\`\`\`
echo The quick brown fox
\`\`\`

Print with quotes:
\`\`\`
echo "This is a quoted string"
\`\`\`

## SEE ALSO

write(1), cat(1)
`,

  'env.1.md': `# NAME

env - display environment variables

## SYNOPSIS

\`env\`

## DESCRIPTION

Display all environment variables and their values. Environment variables are available to all scripts executed with the \`run\` command.

Default environment variables:
- **HOME** - User home directory (/home)
- **USER** - Username (koma)
- **PATH** - Binary search path (/usr/bin)
- **PWD** - Current working directory
- **SHELL** - Shell name (koma)

## EXAMPLES

Show all environment variables:
\`\`\`
env
\`\`\`

## SEE ALSO

run(1), pwd(1)
`,

  'exit.1.md': `# NAME

exit - close current terminal tab

## SYNOPSIS

\`exit\`

## DESCRIPTION

Close the current terminal tab. If this is the last tab, a new default tab will be created.

Tab state (history, working directory) is lost when closed. Use tab persistence (automatic) to restore tabs on page reload.

## EXAMPLES

Close current tab:
\`\`\`
exit
\`\`\`

## SEE ALSO

restart(1), clear(1)
`,

  'help.1.md': `# NAME

help - display available commands

## SYNOPSIS

\`help\`

## DESCRIPTION

Show a list of all available commands with brief descriptions. Also displays keyboard shortcuts and command mode usage.

For detailed information about a specific command, use the man command.

## EXAMPLES

Show all commands:
\`\`\`
help
\`\`\`

Get detailed help for a command:
\`\`\`
man ls
man run
\`\`\`

## SEE ALSO

man(1)
`,

  'history.1.md': `# NAME

history - display command history

## SYNOPSIS

\`history\`

## DESCRIPTION

Display the command history for the current terminal tab. Each tab maintains its own independent command history.

Navigate history with Up/Down arrow keys while typing commands.

## EXAMPLES

Show command history:
\`\`\`
history
\`\`\`

## SEE ALSO

clear(1), help(1)
`,

  'kill.1.md': `# NAME

kill - terminate a process

## SYNOPSIS

\`kill <pid>\`

## DESCRIPTION

Terminate a running process by its process ID (PID). The process is immediately stopped and marked as killed.

Use the \`ps\` command to list running processes and their PIDs.

## EXAMPLES

Kill process 123:
\`\`\`
kill 123
\`\`\`

List processes to find PID:
\`\`\`
ps
kill 456
\`\`\`

## SEE ALSO

ps(1), run(1), cron(1)
`,

  'koma.1.md': `# NAME

koma - Koma system management

## SYNOPSIS

\`\`\`bash
koma version
koma update
koma upgrade
koma reset
\`\`\`

## DESCRIPTION

The \`koma\` command manages the Koma system itself, including version information, system updates, and file restoration.

System updates preserve all user data in \`/home/\` while updating system files in \`/usr/\` and \`/etc/\`. This includes man pages, system scripts, and configuration files.

## SUBCOMMANDS

### koma version

Display detailed system information including:
- Current Koma version
- Build date
- Number of installed man pages
- Last update timestamp
- Update availability status

**Example:**
\`\`\`bash
koma version
\`\`\`

Output:
\`\`\`
Koma 0.5.0
Build date: 2025-11-10
Man pages: 37
Last update: 2025-11-10T15:30:00.000Z
Status: Up to date
\`\`\`

### koma update

Check for available system updates without applying them. Shows what version is available and lists the changes that would be applied.

This command is safe to run at any time and makes no modifications to the system.

**Example:**
\`\`\`bash
koma update
\`\`\`

If updates are available:
\`\`\`
New version available: 0.6.0
Current version: 0.5.0

Changes:
- Updated man pages (42 total)
- System file improvements
- New commands added

Run 'koma upgrade' to install updates
\`\`\`

If no updates:
\`\`\`
System is up to date (version 0.5.0)
\`\`\`

### koma upgrade

Apply available system updates. This command:
- Updates all man pages in \`/usr/share/man/\`
- Updates system files in \`/usr/\` and \`/etc/\`
- Updates the version tracking file \`/etc/koma-version\`
- **Preserves all user data in \`/home/\`**

The upgrade process is safe and cannot damage user files. If something goes wrong, use \`koma reset\` to restore system files to their defaults.

**Example:**
\`\`\`bash
koma upgrade
\`\`\`

Output:
\`\`\`
Upgraded from 0.4.0 to 0.5.0
Updated 37 system files
System restart not required
\`\`\`

**Notes:**
- User data in \`/home/\` is never modified
- The browser tab does not need to be refreshed
- Changes take effect immediately
- Command history and environment variables are preserved

### koma reset

Reset all system files to their default state. This is useful if:
- System files have been corrupted or modified
- Man pages are missing or broken
- You want to restore default configurations

This command:
- Restores all files in \`/usr/share/man/\`
- Resets system files in \`/usr/\` and \`/etc/\`
- **Preserves all user data in \`/home/\`**

**Example:**
\`\`\`bash
koma reset
\`\`\`

Output:
\`\`\`
System files reset to defaults
Reset 37 files
All system files restored
\`\`\`

**Warning:** While this command preserves \`/home/\`, any modifications you made to system files (like scripts in \`/usr/bin/\`) will be lost.

## VERSION TRACKING

Koma tracks system version information in \`/etc/koma-version\`, a JSON file containing:

\`\`\`json
{
  "version": "0.5.0",
  "buildDate": "2025-11-10",
  "updatedAt": "2025-11-10T15:30:00.000Z",
  "manPagesCount": 37
}
\`\`\`

This file is automatically managed by \`koma upgrade\` and \`koma reset\`. Manual modification is not recommended.

## UPDATE SAFETY

The Koma update system follows these safety principles:

1. **User data is sacred** - \`/home/\` is never modified during updates
2. **Non-destructive** - Updates can be rolled back with \`koma reset\`
3. **No downtime** - Updates apply immediately without page refresh
4. **Atomic operations** - Updates either complete fully or not at all
5. **Version tracking** - System always knows what version is installed

## FILES

- \`/etc/koma-version\` - System version information
- \`/usr/share/man/\` - Man page documentation
- \`/home/\` - User data (preserved during updates)

## EXAMPLES

Check if updates are available and apply them:
\`\`\`bash
koma update
koma upgrade
\`\`\`

View current system information:
\`\`\`bash
koma version
\`\`\`

Restore system files after corruption:
\`\`\`bash
koma reset
\`\`\`

## NOTES

- System updates are delivered through the kernel worker
- Updates preserve the IndexedDB-backed virtual filesystem
- Man pages are rebuilt during upgrade from embedded sources
- The update system does not require network access
- Version information is stored in the VFS, not browser storage

## SEE ALSO

help(1), man(1), restart(1)

## HISTORY

The \`koma\` command was introduced in Koma 0.5.0 (Phase 5.5: System Updates) to provide self-update capabilities for the system.
`,

  'komarc.5.md': `# komarc(5) - Shell initialization file

## NAME

komarc - Koma shell initialization file

## SYNOPSIS

\`/home/.komarc\`

## DESCRIPTION

The \`.komarc\` file is the Koma shell initialization file. It is executed automatically when a new shell session (tab) is created, before the welcome message is displayed.

The file is a simple shell script containing commands that are executed sequentially, just like a script run with \`sh(1)\`.

## FILE FORMAT

The \`.komarc\` file follows standard shell script format:

- **One command per line** - Each line is executed as if typed at the shell prompt
- **Comments** - Lines starting with \`#\` are ignored
- **Blank lines** - Empty lines are skipped
- **All commands supported** - Any built-in command, pipeline, or redirect works

## EXECUTION

\`.komarc\` is executed:

- When creating a **new tab** (not when restoring tabs from localStorage)
- **Before** the welcome message is displayed
- **Silently** - Output is not shown unless commands explicitly write to terminal
- **Non-fatal** - Errors in individual commands are logged but don't stop execution
- **Asynchronously** - Each command completes before the next runs

If \`.komarc\` doesn't exist, it is silently ignored (no error).

## TYPICAL USE CASES

### Environment Setup

Set environment variables (when variable support is added in Phase 6):

\`\`\`bash
# Set custom environment
export EDITOR=vein
export PAGER=less
\`\`\`

### Directory Structure

Create standard working directories:

\`\`\`bash
# Create project directories
mkdir -p /home/projects
mkdir -p /home/scripts
mkdir -p /home/data
\`\`\`

### Startup Messages

Display custom welcome messages:

\`\`\`bash
# Show system info
echo "Welcome to Koma Workstation"
echo ""
\`\`\`

### Background Processes

Start long-running processes (when background jobs are supported):

\`\`\`bash
# Start monitoring scripts
# run /home/scripts/monitor.js &
\`\`\`

### Aliases and Functions

(Future: when aliases/functions are added in Phase 7)

\`\`\`bash
# Define shortcuts
alias ll='ls -la'
alias ..='cd ..'
\`\`\`

## EXAMPLE

Here's a complete example \`.komarc\`:

\`\`\`bash
# Koma Shell Configuration
# ~/.komarc

# Welcome message
echo "Koma Workstation - Olivine Kernel"
echo ""

# Create standard directories
mkdir -p /home/projects
mkdir -p /home/scripts
mkdir -p /home/tmp

# Set up project structure
cd /home/projects

# Download useful scripts (example)
# wget https://example.com/utils.js -O /home/scripts/utils.js

# Display current status
echo "Workspace initialized"
\`\`\`

## DEBUGGING

To see what commands are executed from \`.komarc\`, temporarily add \`echo\` statements:

\`\`\`bash
echo "Loading .komarc..."

mkdir -p /home/projects
echo "Created /home/projects"

cd /home/projects
echo "Changed to projects directory"
\`\`\`

Or check the browser console (F12) for any error messages.

## FILES

- \`/home/.komarc\` - User initialization file (the only location checked)

## NOTES

- \`.komarc\` is **not** executed when tabs are restored from localStorage (on page reload)
- This prevents duplicate execution and maintains tab state
- Commands that fail continue to next line (like \`sh -c\` but more forgiving)
- Output from \`.komarc\` commands is not shown by default

## CREATING .KOMARC

Use the built-in editor:

\`\`\`bash
vein /home/.komarc
\`\`\`

Or write from command line:

\`\`\`bash
echo "# Koma initialization" > /home/.komarc
echo "mkdir -p /home/projects" >> /home/.komarc
\`\`\`

Then open a new tab to test it.

## RETROSPEC NOTE

The \`.rc\` (run commands) file convention dates to Unix's early days:

- \`.profile\` - Bourne shell (1979)
- \`.cshrc\` - C shell (1978)
- \`.bashrc\` - Bash (1989)

Koma's \`.komarc\` follows this time-honored tradition. In 1984-1987, a workstation would absolutely have had an initialization file for customizing the shell environment.

## SEE ALSO

\`sh(1)\` - Execute shell scripts
\`koma(1)\` - Koma system commands
\`env(1)\` - View environment variables

## HISTORY

Added in Koma v0.1 (Phase 5 → Phase 6 transition)

---

**Koma Terminal**
Craton Systems, Inc.
Part of the Koma Workstation suite
`,

  'man.1.md': `# NAME

man - display manual pages

## SYNOPSIS

\`man <command>\`

## DESCRIPTION

Display the manual page for a command. Manual pages provide detailed information about command usage, options, examples, and related commands.

Manual pages use standard sections:
- **NAME** - Command name and brief description
- **SYNOPSIS** - Command syntax
- **DESCRIPTION** - Detailed description
- **OPTIONS** - Available flags and options (if any)
- **EXAMPLES** - Usage examples
- **SEE ALSO** - Related commands

## EXAMPLES

Read ls manual:
\`\`\`
man ls
\`\`\`

Read run manual:
\`\`\`
man run
\`\`\`

Read cron manual:
\`\`\`
man cron
\`\`\`

## SEE ALSO

help(1), version(1)
`,

  'ps.1.md': `# NAME

ps - list running processes

## SYNOPSIS

\`ps\`

## DESCRIPTION

Display all running and recent processes. Shows process ID, status, runtime, and script path.

Process states:
- **running** - Currently executing
- **completed** - Finished successfully
- **failed** - Exited with error
- **killed** - Terminated by kill command

## EXAMPLES

List all processes:
\`\`\`
ps
\`\`\`

## SEE ALSO

run(1), kill(1)
`,

  'restart.1.md': `# NAME

restart - restart the Olivine kernel

## SYNOPSIS

\`restart\`

## DESCRIPTION

Restart the Olivine kernel (Web Worker). This reinitializes the virtual filesystem from IndexedDB and reloads all system state.

Useful for troubleshooting or applying system changes. All tabs and terminal sessions remain active.

**Warning:** Running processes and cron jobs will be terminated.

## EXAMPLES

Restart kernel:
\`\`\`
restart
\`\`\`

## SEE ALSO

version(1), ps(1), cronlist(1)
`,

  'run.1.md': `# NAME

run - execute JavaScript file as a process

## SYNOPSIS

\`run <script> [args...]\`

## DESCRIPTION

Execute a JavaScript file in the Olivine kernel. The script runs with access to the Koma standard library and can receive command-line arguments.

Scripts have access to:
- **args** - Command-line arguments array
- **env** - Environment variables object
- **console** - Console for stdout/stderr (log, error)
- **fs** - Filesystem module (readFile, writeFile, mkdir, etc.)
- **http** - HTTP module (get, post, json, text)
- **notify** - Notifications module
- **path** - Path utilities (join, resolve, dirname, etc.)
- **argparse** - Argument parsing (parse, usage, hasFlag, etc.)

## EXAMPLES

Run a script:
\`\`\`
run /home/hello.js
\`\`\`

Run with arguments:
\`\`\`
run script.js arg1 arg2
\`\`\`

Example script (/home/hello.js):
\`\`\`
console.log('Hello from Koma!');
console.log('Arguments:', args);
console.log('Home directory:', env.HOME);

const files = await fs.readdir(env.HOME);
console.log('Files in home:', files);
\`\`\`

## SEE ALSO

ps(1), kill(1), cron(1)
`,

  'sh.1.md': `# NAME

sh - execute shell script file

## SYNOPSIS

\`\`\`bash
sh <script>
sh -v <script>
\`\`\`

## DESCRIPTION

The \`sh\` command executes shell scripts - text files containing shell commands (one per line). Each line is executed as if you typed it directly into the terminal.

Shell scripts enable automation, batch operations, and complex workflows using the commands and pipes you already know.

## OPTIONS

### -v, --verbose

Show each command before executing it. Useful for debugging scripts or understanding what they do.

## SCRIPT FORMAT

Shell scripts are plain text files with:
- **One command per line** - Each line is executed sequentially
- **Comments** - Lines starting with \`#\` are ignored
- **Empty lines** - Blank lines are skipped
- **All shell features** - Pipes, redirects, and all built-in commands work

**Example script** (\`setup.sh\`):
\`\`\`bash
# Project setup script
mkdir myproject
cd myproject
echo "console.log('Hello')" > app.js
echo "# My Project" > README.md
ls -l
\`\`\`

## EXAMPLES

### Basic script execution

Create and run a simple script:
\`\`\`bash
echo "# Hello script" > hello.sh
echo "echo 'Hello, World!'" >> hello.sh
echo "ls" >> hello.sh
sh hello.sh
\`\`\`

### Verbose mode

See what the script is doing:
\`\`\`bash
sh -v setup.sh
\`\`\`

Output:
\`\`\`
+ mkdir myproject
+ cd myproject
+ echo "console.log('Hello')" > app.js
...
\`\`\`

### Automation script

Create a backup script (\`backup.sh\`):
\`\`\`bash
# Backup important files
echo "Creating backup..."
mkdir -p /home/backup
cp /home/config.json /home/backup/
cp /home/data.txt /home/backup/
ls /home/backup
echo "Backup complete"
\`\`\`

Run it:
\`\`\`bash
sh backup.sh
\`\`\`

### Data processing pipeline

Create a log analyzer (\`analyze.sh\`):
\`\`\`bash
# Analyze log file
echo "Analyzing logs..."
grep error log.txt | sort | uniq -c > error-summary.txt
grep warning log.txt | wc -l > warning-count.txt
cat error-summary.txt
echo "Total warnings:"
cat warning-count.txt
\`\`\`

### Build script

Create a build process (\`build.sh\`):
\`\`\`bash
# Build project
echo "Building project..."
find /home/project -name "*.js" > source-files.txt
cat source-files.txt | wc -l
echo "Build complete"
\`\`\`

### Installation script

Setup a new environment (\`install.sh\`):
\`\`\`bash
# Setup development environment
mkdir -p /home/dev/src
mkdir -p /home/dev/dist
mkdir -p /home/dev/tests
echo "console.log('test')" > /home/dev/tests/test.js
tree /home/dev
\`\`\`

## SCRIPT BEST PRACTICES

### Use comments

Document what your script does:
\`\`\`bash
# Setup project structure
mkdir project

# Initialize files
echo "# Project" > project/README.md

# Show results
ls project
\`\`\`

### Error handling

Scripts continue even if a command fails. Use \`echo\` to show progress:
\`\`\`bash
echo "Step 1: Creating directories..."
mkdir project
echo "Step 2: Creating files..."
echo "content" > project/file.txt
echo "Done!"
\`\`\`

### Test incrementally

Build scripts one command at a time:
1. Test each command manually
2. Add it to the script
3. Test the script
4. Add the next command

### Use pipes and redirects

Take advantage of shell features:
\`\`\`bash
# Find and count
find /home -name "*.txt" | wc -l > txt-count.txt

# Filter and save
ls | grep ".js" | sort > js-files.txt

# Process and display
cat data.txt | sort | uniq | tee results.txt
\`\`\`

## CREATING SCRIPTS

### Method 1: Using echo

\`\`\`bash
echo "# My script" > script.sh
echo "echo 'Hello'" >> script.sh
echo "ls" >> script.sh
sh script.sh
\`\`\`

### Method 2: Using vein editor

\`\`\`bash
vein script.sh
# Write your script, press Ctrl+S to save
sh script.sh
\`\`\`

### Method 3: Using write command

\`\`\`bash
write script.sh <<EOF
# My script
echo "Starting..."
mkdir test
echo "Done"
EOF
sh script.sh
\`\`\`

## LIMITATIONS

Current limitations (will be improved in future phases):

- **No variables** - Cannot store values like \`NAME=foo\`
- **No control flow** - No if/then/else or loops
- **No functions** - Cannot define reusable functions
- **No exit codes** - Cannot check if commands succeeded
- **Line-by-line** - Each line executes independently

Despite these limitations, shell scripts are still very useful for:
- Automation
- Batch operations
- File organization
- Data processing
- Setup procedures

## COMPARISON WITH RUN

- **\`sh\`** - Executes shell commands (what you type in the terminal)
- **\`run\`** - Executes JavaScript code (programming language)

**Use \`sh\` when:**
- Automating terminal tasks
- Batch file operations
- Using pipes and commands

**Use \`run\` when:**
- Need variables and logic
- Complex calculations
- Data manipulation
- API interactions

## NOTES

- Scripts are just text files with commands
- Each line executes in sequence
- Comments (\`#\`) and blank lines are ignored
- All shell features work (pipes, redirects, etc.)
- Errors don't stop execution (remaining lines still run)
- Use \`-v\` to debug and see what's happening
- No file extension required, but \`.sh\` is conventional

## SEE ALSO

run(1), echo(1), cat(1), vein(1), write(1)
`,

  'version.1.md': `# NAME

version - display Koma version information

## SYNOPSIS

\`version\`

## DESCRIPTION

Display version information for Koma terminal, including:
- Koma version number
- Olivine kernel version
- Project description
- GitHub repository URL

## EXAMPLES

Show version information:
\`\`\`
version
\`\`\`

## SEE ALSO

help(1)
`,

  'wget.1.md': `# NAME

wget - download files from URLs

## SYNOPSIS

\`\`\`bash
wget <url>
wget <url> -O <filename>
wget -q <url>
\`\`\`

## DESCRIPTION

The \`wget\` command downloads files from HTTP/HTTPS URLs and saves them to the virtual filesystem. It automatically extracts the filename from the URL or you can specify a custom name.

This is useful for:
- Downloading data files from APIs
- Fetching configuration files
- Getting JSON data
- Downloading scripts or text files

## OPTIONS

### -O, --output FILENAME

Save the downloaded file with a specific name. If not specified, wget extracts the filename from the URL.

**Example:**
\`\`\`bash
wget https://example.com/data.json -O mydata.json
\`\`\`

### -q, --quiet

Quiet mode - suppress progress and status messages. Only errors are shown.

**Example:**
\`\`\`bash
wget -q https://api.github.com/users/octocat
\`\`\`

## EXAMPLES

### Download with auto-detected filename

\`\`\`bash
wget https://example.com/data.json
\`\`\`

Downloads and saves as \`data.json\` in current directory.

### Specify output filename

\`\`\`bash
wget https://api.github.com/users/octocat -O github-user.json
\`\`\`

Saves the API response as \`github-user.json\`.

### Download in quiet mode

\`\`\`bash
wget -q https://example.com/config.txt
\`\`\`

Downloads without showing progress messages.

### Download to specific directory

\`\`\`bash
cd /home/downloads
wget https://example.com/file.txt
\`\`\`

Downloads to \`/home/downloads/file.txt\`.

### Use in shell scripts

\`\`\`bash
# download-data.sh
echo "Fetching data..."
wget https://api.example.com/data.json -O data.json
echo "Processing data..."
cat data.json | grep "status"
echo "Done!"
\`\`\`

### Download and process in pipeline

\`\`\`bash
wget -q https://api.github.com/users/octocat -O user.json && cat user.json
\`\`\`

Downloads and then displays the content.

## PRACTICAL USE CASES

### Download configuration files

\`\`\`bash
wget https://raw.githubusercontent.com/user/repo/main/config.json
\`\`\`

### Fetch API data

\`\`\`bash
wget https://api.github.com/repos/anthropics/claude-code -O repo-info.json
cat repo-info.json
\`\`\`

### Download and analyze

\`\`\`bash
wget https://example.com/log.txt
grep error log.txt | wc -l
\`\`\`

### Batch downloads in script

Create \`download.sh\`:
\`\`\`bash
# Download multiple files
wget https://example.com/file1.txt
wget https://example.com/file2.txt
wget https://example.com/file3.txt
ls *.txt
\`\`\`

Run: \`sh download.sh\`

### Download JSON and extract data

\`\`\`bash
wget https://api.github.com/users/octocat -O user.json
cat user.json
# Manual JSON inspection (no jq yet, but coming in Phase 6!)
\`\`\`

## OUTPUT FORMAT

### Default output

\`\`\`
Downloading https://example.com/data.json...
Saved to data.json (1.25 KB)
Content-Type: application/json
\`\`\`

### Quiet mode

No output on success. Errors still shown:
\`\`\`
wget: HTTP 404: Not Found
\`\`\`

## FILENAME EXTRACTION

wget automatically extracts filenames from URLs:

\`\`\`
https://example.com/data.json        → data.json
https://example.com/path/to/file.txt → file.txt
https://example.com/                  → index.html
https://api.github.com               → api_github_com.txt
\`\`\`

If no filename can be determined, uses \`downloaded_file.txt\`.

## CORS AND SECURITY

- Subject to browser CORS policies
- Can only fetch from servers that allow cross-origin requests
- Most public APIs (GitHub, etc.) support CORS
- Some websites may block requests

If you get CORS errors, the server doesn't allow browser requests.

## LIMITATIONS

Current limitations:

- **Text files only** - Binary files not supported yet (coming later)
- **No progress bar** - Just status messages
- **No resume** - Cannot resume interrupted downloads
- **No authentication** - No support for auth headers yet
- **CORS restrictions** - Subject to browser same-origin policy

Despite these limitations, wget is very useful for:
- Public APIs
- JSON data
- Configuration files
- Text-based resources
- Scripts and documentation

## NOTES

- Downloads are stored in the IndexedDB-backed VFS
- Files persist across page reloads
- Subject to browser storage limits
- Use \`-O\` to control filename
- Automatically handles HTTP redirects
- Shows file size and content type on success
- Only errors shown in quiet mode

## TROUBLESHOOTING

### "Invalid URL"
Ensure URL starts with \`http://\` or \`https://\`

### "CORS error" or "Network error"
The server doesn't allow browser requests. Try a different URL or use an API that supports CORS.

### "HTTP 404" or other errors
The URL doesn't exist or server is unavailable.

### Large files
Files are stored in IndexedDB. Very large downloads may exceed browser quotas.

## SEE ALSO

cat(1), sh(1), run(1)
`,

  'argparse.3.md': `# NAME

argparse - command-line argument parsing for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'argparse' module
const parsed = argparse.parse(args, {
  flags: {
    verbose: { short: 'v', description: 'Verbose output' }
  },
  options: {
    output: { short: 'o', description: 'Output file' }
  }
});

console.log('Verbose:', parsed.flags.verbose);
console.log('Output:', parsed.options.output);
\`\`\`

## DESCRIPTION

The \`argparse\` module provides robust command-line argument parsing for Koma scripts. It supports boolean flags, options with values, positional arguments, combined short flags, and automatic help text generation.

This is the same module used by built-in Koma commands.

## SCHEMA FORMAT

Argument schemas define what arguments your script accepts:

\`\`\`javascript
const schema = {
  description: 'Brief description of the script',

  flags: {
    flagName: {
      short: 'f',                  // Short form: -f
      description: 'Flag description'
    }
  },

  options: {
    optionName: {
      short: 'o',                  // Short form: -o
      description: 'Option description',
      default: 'defaultValue',     // Optional default
      choices: ['a', 'b', 'c']     // Optional allowed values
    }
  },

  positional: {
    description: '<input> [output]'  // Positional args format
  },

  examples: [
    { command: 'script.js input.txt', description: 'Process input.txt' }
  ],

  notes: [
    'Additional note 1',
    'Additional note 2'
  ],

  seeAlso: ['other-command', 'man page']
};
\`\`\`

## FUNCTIONS

### argparse.parse(argv, schema)

Parse command-line arguments according to a schema.

**Parameters:**
- \`argv\` (Array\\<string\\>) - Arguments array (usually from \`args\` global)
- \`schema\` (object, optional) - Argument schema defining flags and options

**Returns:** object - Parsed arguments with properties:
- \`flags\` (object) - Boolean flags (true/false)
- \`options\` (object) - Options with values
- \`positional\` (array) - Positional arguments
- \`_\` (array) - Alias for positional
- \`errors\` (array) - Parsing errors (if any)

**Example:**
\`\`\`javascript
const schema = {
  flags: {
    verbose: { short: 'v' },
    quiet: { short: 'q' }
  },
  options: {
    output: { short: 'o' },
    format: { short: 'f', choices: ['json', 'text'] }
  }
};

const parsed = argparse.parse(args, schema);

if (parsed.errors.length > 0) {
  parsed.errors.forEach(err => console.error('Error:', err));
  return;
}

if (parsed.flags.verbose) {
  console.log('Verbose mode enabled');
}

if (parsed.options.output) {
  console.log('Output to:', parsed.options.output);
}

console.log('Files:', parsed.positional);
\`\`\`

### argparse.usage(commandName, schema)

Generate formatted usage text from a schema.

**Parameters:**
- \`commandName\` (string) - Name of the command/script
- \`schema\` (object) - Argument schema

**Returns:** Array\\<string\\> - Array of formatted lines

**Example:**
\`\`\`javascript
const usage = argparse.usage('myscript', schema);
usage.forEach(line => console.log(line));
\`\`\`

### argparse.hasHelp(argv)

Check if help flag is present (--help or -h).

**Parameters:**
- \`argv\` (Array\\<string\\>) - Arguments array

**Returns:** boolean - True if help flag present

**Example:**
\`\`\`javascript
if (argparse.hasHelp(args)) {
  console.log('Help requested');
}
\`\`\`

### argparse.showHelp(commandName, argv, schema, term)

Display help text if help flag is present. This is a convenience function used by built-in commands.

**Parameters:**
- \`commandName\` (string) - Command name
- \`argv\` (Array\\<string\\>) - Arguments array
- \`schema\` (object) - Argument schema
- \`term\` (object) - Terminal with writeln method (for internal use)

**Returns:** boolean - True if help was shown

**Note:** In scripts, use \`hasHelp()\` and \`usage()\` instead since you don't have access to the terminal object.

### argparse.hasFlag(argv, flag)

Quick check if a specific flag is present.

**Parameters:**
- \`argv\` (Array\\<string\\>) - Arguments array
- \`flag\` (string) - Flag name (with or without --)

**Returns:** boolean - True if flag present

**Example:**
\`\`\`javascript
if (argparse.hasFlag(args, '--verbose')) {
  console.log('Verbose mode');
}
if (argparse.hasFlag(args, 'v')) {
  console.log('Short form -v present');
}
\`\`\`

### argparse.getOption(argv, option, defaultValue)

Get value of a specific option.

**Parameters:**
- \`argv\` (Array\\<string\\>) - Arguments array
- \`option\` (string) - Option name (with or without --)
- \`defaultValue\` (any, optional) - Default if not present

**Returns:** any - Option value or default

**Example:**
\`\`\`javascript
const output = argparse.getOption(args, 'output', 'default.txt');
console.log('Output file:', output);
\`\`\`

## ARGUMENT FORMATS

### Boolean flags

\`\`\`bash
script.js --verbose           # Long form
script.js -v                  # Short form
script.js -v --quiet          # Multiple flags
script.js -vq                 # Combined short flags
\`\`\`

### Options with values

\`\`\`bash
script.js --output=file.txt   # Long form with =
script.js --output file.txt   # Long form with space
script.js -o file.txt         # Short form with space
script.js -vo output.txt      # Combined flags + option
\`\`\`

### Positional arguments

\`\`\`bash
script.js file1.txt file2.txt    # Positional args
script.js -v file1.txt file2.txt # Flags + positional
\`\`\`

### Stop parsing with --

\`\`\`bash
script.js -- --not-a-flag     # Everything after -- is positional
\`\`\`

## COMPLETE EXAMPLES

### Simple script with flags

\`\`\`javascript
// myscript.js - Count lines in files
const schema = {
  description: 'Count lines in files',
  flags: {
    verbose: { short: 'v', description: 'Show detailed output' },
    total: { short: 't', description: 'Show total only' }
  },
  positional: { description: '<file> [files...]' },
  examples: [
    { command: 'myscript.js file.txt', description: 'Count lines in file' },
    { command: 'myscript.js -v *.txt', description: 'Verbose output' }
  ]
};

// Show help if requested
if (argparse.hasHelp(args)) {
  const usage = argparse.usage('myscript.js', schema);
  usage.forEach(line => console.log(line));
  return;
}

// Parse arguments
const parsed = argparse.parse(args, schema);

if (parsed.errors.length > 0) {
  parsed.errors.forEach(err => console.error('Error:', err));
  return;
}

if (parsed.positional.length === 0) {
  console.error('Error: No files specified');
  return;
}

// Process files
let totalLines = 0;
for (const file of parsed.positional) {
  const content = await fs.readFile(file);
  const lines = content.split('\\n').length;
  totalLines += lines;

  if (!parsed.flags.total) {
    console.log(\`\${lines} \${file}\`);
  }
}

if (parsed.flags.verbose || parsed.flags.total) {
  console.log(\`Total: \${totalLines} lines\`);
}
\`\`\`

### Script with options and validation

\`\`\`javascript
// converter.js - Convert file formats
const schema = {
  description: 'Convert file between formats',
  flags: {
    force: { short: 'f', description: 'Overwrite existing files' }
  },
  options: {
    format: {
      short: 'F',
      description: 'Output format',
      choices: ['json', 'yaml', 'toml'],
      default: 'json'
    },
    output: {
      short: 'o',
      description: 'Output file'
    }
  },
  positional: { description: '<input>' },
  examples: [
    { command: 'converter.js data.yaml', description: 'Convert to JSON' },
    { command: 'converter.js -F yaml data.json', description: 'Convert to YAML' },
    { command: 'converter.js -o out.json data.yaml', description: 'Specify output' }
  ]
};

if (argparse.hasHelp(args)) {
  argparse.usage('converter.js', schema).forEach(line => console.log(line));
  return;
}

const parsed = argparse.parse(args, schema);

// Check for errors (includes validation of choices)
if (parsed.errors.length > 0) {
  parsed.errors.forEach(err => console.error(err));
  return;
}

// Validate required arguments
if (parsed.positional.length === 0) {
  console.error('Error: Input file required');
  return;
}

const input = parsed.positional[0];
const format = parsed.options.format;
const output = parsed.options.output || input.replace(/\\.\\w+$/, \`.\${format}\`);

console.log(\`Converting \${input} to \${format} format...\`);
console.log(\`Output: \${output}\`);

// Check if output exists
if (await fs.exists(output) && !parsed.flags.force) {
  console.error(\`Error: \${output} exists. Use --force to overwrite.\`);
  return;
}

// Conversion logic would go here...
\`\`\`

### Using quick parse functions

\`\`\`javascript
// Simple flag checking without full parsing
if (argparse.hasFlag(args, 'help')) {
  console.log('Usage: script.js [options] <files...>');
  return;
}

const verbose = argparse.hasFlag(args, 'verbose');
const output = argparse.getOption(args, 'output', 'default.txt');

if (verbose) {
  console.log(\`Output file: \${output}\`);
}
\`\`\`

## NOTES

- All flags are optional and default to false
- Options can have default values and validation via choices
- Combined short flags like \`-abc\` expand to \`-a -b -c\`
- Last character in combined flags can be an option: \`-vo file.txt\` = \`-v -o file.txt\`
- Use \`--\` to stop parsing flags (everything after is positional)
- Schema is optional - parse() works without one for simple cases
- Error checking is important - always check \`parsed.errors.length\`

## SEE ALSO

run(1), env(1), echo(1)
`,

  'fs.3.md': `# NAME

fs - filesystem API for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'fs' module
const content = await fs.readFile('/home/file.txt');
await fs.writeFile('/home/output.txt', 'Hello, World!');
const files = await fs.readdir('/home');
\`\`\`

## DESCRIPTION

The \`fs\` module provides access to the virtual filesystem (VFS) from JavaScript scripts executed with the \`run\` command. All operations are asynchronous and return Promises.

## FUNCTIONS

### fs.readFile(path)

Read file contents as a string.

**Parameters:**
- \`path\` (string) - File path to read

**Returns:** Promise\\<string\\> - File contents

**Throws:** Error with 'ENOENT' if file doesn't exist

**Example:**
\`\`\`javascript
const content = await fs.readFile('/home/config.json');
const config = JSON.parse(content);
console.log('Config loaded:', config);
\`\`\`

### fs.writeFile(path, content)

Write content to a file. Creates the file if it doesn't exist, overwrites if it does.

**Parameters:**
- \`path\` (string) - File path to write
- \`content\` (string) - Content to write

**Returns:** Promise\\<void\\>

**Example:**
\`\`\`javascript
await fs.writeFile('/home/log.txt', 'Application started\\n');
console.log('Log file created');
\`\`\`

### fs.appendFile(path, content)

Append content to a file. Creates the file if it doesn't exist.

**Parameters:**
- \`path\` (string) - File path to append to
- \`content\` (string) - Content to append

**Returns:** Promise\\<void\\>

**Example:**
\`\`\`javascript
await fs.appendFile('/home/log.txt', 'New log entry\\n');
\`\`\`

### fs.readdir(path)

Read directory contents.

**Parameters:**
- \`path\` (string) - Directory path to read

**Returns:** Promise\\<Array\\<Object\\>\\> - Array of directory entries with properties:
- \`name\` (string) - Entry name
- \`type\` (string) - 'file' or 'directory'
- \`size\` (number) - Size in bytes (files only)
- \`modified\` (Date) - Last modified timestamp

**Example:**
\`\`\`javascript
const entries = await fs.readdir('/home');
for (const entry of entries) {
  console.log(\`\${entry.type}: \${entry.name}\`);
}
\`\`\`

### fs.mkdir(path)

Create a directory.

**Parameters:**
- \`path\` (string) - Directory path to create

**Returns:** Promise\\<void\\>

**Throws:** Error if parent directory doesn't exist

**Example:**
\`\`\`javascript
await fs.mkdir('/home/projects');
console.log('Directory created');
\`\`\`

### fs.unlink(path)

Delete a file or empty directory.

**Parameters:**
- \`path\` (string) - Path to delete

**Returns:** Promise\\<void\\>

**Throws:** Error if directory is not empty

**Example:**
\`\`\`javascript
await fs.unlink('/home/temp.txt');
console.log('File deleted');
\`\`\`

### fs.rename(oldPath, newPath)

Rename or move a file or directory.

**Parameters:**
- \`oldPath\` (string) - Current path
- \`newPath\` (string) - New path

**Returns:** Promise\\<void\\>

**Example:**
\`\`\`javascript
await fs.rename('/home/old.txt', '/home/new.txt');
console.log('File renamed');
\`\`\`

### fs.stat(path)

Get file or directory metadata.

**Parameters:**
- \`path\` (string) - Path to stat

**Returns:** Promise\\<Object\\> - Metadata object with properties:
- \`type\` (string) - 'file' or 'directory'
- \`size\` (number) - Size in bytes
- \`inode\` (number) - Inode number
- \`created\` (Date) - Creation timestamp
- \`modified\` (Date) - Last modified timestamp
- \`accessed\` (Date) - Last accessed timestamp

**Example:**
\`\`\`javascript
const stat = await fs.stat('/home/file.txt');
console.log(\`Size: \${stat.size} bytes\`);
console.log(\`Modified: \${stat.modified}\`);
\`\`\`

### fs.exists(path)

Check if a path exists.

**Parameters:**
- \`path\` (string) - Path to check

**Returns:** Promise\\<boolean\\> - True if exists, false otherwise

**Example:**
\`\`\`javascript
if (await fs.exists('/home/config.json')) {
  console.log('Config file exists');
} else {
  console.log('Config file not found');
}
\`\`\`

### fs.isFile(path)

Check if a path is a file.

**Parameters:**
- \`path\` (string) - Path to check

**Returns:** Promise\\<boolean\\> - True if path exists and is a file

**Example:**
\`\`\`javascript
if (await fs.isFile('/home/script.js')) {
  console.log('It is a file');
}
\`\`\`

### fs.isDirectory(path)

Check if a path is a directory.

**Parameters:**
- \`path\` (string) - Path to check

**Returns:** Promise\\<boolean\\> - True if path exists and is a directory

**Example:**
\`\`\`javascript
if (await fs.isDirectory('/home')) {
  console.log('It is a directory');
}
\`\`\`

## COMPLETE EXAMPLE

\`\`\`javascript
// Create a backup script
const source = '/home/data.txt';
const backup = '/home/data.backup.txt';

// Check if source exists
if (await fs.exists(source)) {
  // Read source content
  const content = await fs.readFile(source);

  // Write backup
  await fs.writeFile(backup, content);

  // Verify backup
  const stat = await fs.stat(backup);
  console.log(\`Backup created: \${stat.size} bytes\`);
} else {
  console.error('Source file not found');
}
\`\`\`

## SEE ALSO

run(1), path(3), cat(1), ls(1), mkdir(1)
`,

  'http.3.md': `# NAME

http - HTTP client API for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'http' module
const response = await http.get('https://api.example.com/data');
const data = await http.json('https://api.example.com/users');
await http.post('https://api.example.com/submit', { name: 'Alice' });
\`\`\`

## DESCRIPTION

The \`http\` module provides a simplified interface for making HTTP requests from JavaScript scripts. It wraps the browser's \`fetch()\` API with convenient methods for common operations.

All functions return Promises and can be used with async/await.

## FUNCTIONS

### http.fetch(url, options)

Make a raw HTTP request using the Fetch API.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Fetch options (method, headers, body, etc.)

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
const response = await http.fetch('https://api.example.com/data', {
  method: 'GET',
  headers: { 'Authorization': 'Bearer token123' }
});
console.log('Status:', response.status);
\`\`\`

### http.get(url, options)

Make a GET request.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Additional fetch options

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
const response = await http.get('https://api.example.com/users');
const users = await response.json();
console.log('Users:', users);
\`\`\`

### http.post(url, body, options)

Make a POST request. Automatically stringifies objects to JSON and sets Content-Type header.

**Parameters:**
- \`url\` (string) - URL to request
- \`body\` (any) - Request body (objects are JSON stringified)
- \`options\` (object, optional) - Additional fetch options

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
const response = await http.post('https://api.example.com/users', {
  name: 'Alice',
  email: 'alice@example.com'
});
console.log('Created:', await response.json());
\`\`\`

### http.put(url, body, options)

Make a PUT request. Automatically stringifies objects to JSON.

**Parameters:**
- \`url\` (string) - URL to request
- \`body\` (any) - Request body
- \`options\` (object, optional) - Additional fetch options

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
await http.put('https://api.example.com/users/123', {
  name: 'Alice Updated'
});
console.log('User updated');
\`\`\`

### http.delete(url, options)

Make a DELETE request.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Additional fetch options

**Returns:** Promise\\<Response\\> - Fetch Response object

**Example:**
\`\`\`javascript
await http.delete('https://api.example.com/users/123');
console.log('User deleted');
\`\`\`

### http.json(url, options)

Make a GET request and parse response as JSON. Throws error on non-2xx status codes.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Fetch options

**Returns:** Promise\\<any\\> - Parsed JSON response

**Throws:** Error with HTTP status if response is not ok

**Example:**
\`\`\`javascript
try {
  const data = await http.json('https://api.example.com/config');
  console.log('Config:', data);
} catch (error) {
  console.error('Failed to fetch:', error.message);
}
\`\`\`

### http.text(url, options)

Make a GET request and get response as text. Throws error on non-2xx status codes.

**Parameters:**
- \`url\` (string) - URL to request
- \`options\` (object, optional) - Fetch options

**Returns:** Promise\\<string\\> - Response text

**Throws:** Error with HTTP status if response is not ok

**Example:**
\`\`\`javascript
const html = await http.text('https://example.com');
console.log('Page length:', html.length);
\`\`\`

## COMPLETE EXAMPLES

### Fetch and save API data

\`\`\`javascript
// Fetch JSON data and save to file
const users = await http.json('https://jsonplaceholder.typicode.com/users');
await fs.writeFile('/home/users.json', JSON.stringify(users, null, 2));
console.log(\`Saved \${users.length} users to file\`);
\`\`\`

### POST with error handling

\`\`\`javascript
try {
  const response = await http.post('https://api.example.com/submit', {
    message: 'Hello from Koma!'
  });

  if (response.ok) {
    const result = await response.json();
    console.log('Success:', result);
  } else {
    console.error(\`HTTP \${response.status}: \${response.statusText}\`);
  }
} catch (error) {
  console.error('Request failed:', error.message);
}
\`\`\`

### Custom headers

\`\`\`javascript
const response = await http.get('https://api.example.com/protected', {
  headers: {
    'Authorization': 'Bearer my-token',
    'X-Custom-Header': 'value'
  }
});
const data = await response.json();
\`\`\`

## NOTES

- All HTTP requests are subject to CORS restrictions
- The \`json()\` and \`text()\` convenience methods automatically check response.ok
- Objects passed to \`post()\` and \`put()\` are automatically JSON stringified
- For file uploads or other binary data, use \`fetch()\` directly with FormData

## SEE ALSO

run(1), fs(3), cron(1)
`,

  'notify.3.md': `# NAME

notify - browser notifications API for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'notify' module
await notify.send('Task Complete', 'Your script has finished running');
await notify.error('Error', 'Something went wrong');
const hasPermission = notify.permission() === 'granted';
\`\`\`

## DESCRIPTION

The \`notify\` module provides access to browser notifications from JavaScript scripts. Notifications can alert users to events even when Koma is running in a background tab.

**Note:** Currently only available from the main UI context. Scripts running in the Olivine worker cannot directly create notifications but this module is included for future use.

## FUNCTIONS

### notify.isSupported()

Check if the browser supports notifications.

**Returns:** boolean - True if notifications are supported

**Example:**
\`\`\`javascript
if (notify.isSupported()) {
  console.log('Notifications available');
} else {
  console.log('Notifications not supported');
}
\`\`\`

### notify.permission()

Get the current notification permission status.

**Returns:** string - One of:
- \`'granted'\` - User has granted permission
- \`'denied'\` - User has denied permission
- \`'default'\` - Permission not yet requested

**Example:**
\`\`\`javascript
const status = notify.permission();
if (status === 'granted') {
  console.log('Can send notifications');
} else if (status === 'denied') {
  console.log('Notifications blocked');
} else {
  console.log('Need to request permission');
}
\`\`\`

### notify.requestPermission()

Request notification permission from the user. Browser will show a permission prompt.

**Returns:** Promise\\<string\\> - Permission result ('granted' or 'denied')

**Throws:** Error if notifications not supported

**Example:**
\`\`\`javascript
const permission = await notify.requestPermission();
if (permission === 'granted') {
  console.log('Permission granted!');
} else {
  console.log('Permission denied');
}
\`\`\`

### notify.notify(title, options)

Show a notification with custom options.

**Parameters:**
- \`title\` (string) - Notification title
- \`options\` (object, optional) - Notification options:
  - \`body\` (string) - Notification body text
  - \`icon\` (string) - Icon URL (defaults to /favicon.ico)
  - \`tag\` (string) - Notification tag for grouping
  - \`requireInteraction\` (boolean) - Keep notification until user interacts
  - \`silent\` (boolean) - Suppress notification sound

**Returns:** Promise\\<Notification\\> - Notification object

**Throws:** Error if permission not granted or not supported

**Example:**
\`\`\`javascript
await notify.notify('Build Complete', {
  body: 'Your project built successfully',
  icon: '/icons/success.png',
  tag: 'build',
  requireInteraction: false
});
\`\`\`

### notify.send(title, body)

Show a simple notification with title and body text. Automatically requests permission if needed.

**Parameters:**
- \`title\` (string) - Notification title
- \`body\` (string, optional) - Notification body text

**Returns:** Promise\\<Notification\\> - Notification object

**Example:**
\`\`\`javascript
await notify.send('Task Complete', 'The task finished successfully');
\`\`\`

### notify.error(title, body)

Show an error notification. Stays visible until user dismisses it.

**Parameters:**
- \`title\` (string) - Error title
- \`body\` (string, optional) - Error message

**Returns:** Promise\\<Notification\\> - Notification object

**Example:**
\`\`\`javascript
await notify.error('Script Failed', 'Failed to connect to API');
\`\`\`

### notify.success(title, body)

Show a success notification.

**Parameters:**
- \`title\` (string) - Success title
- \`body\` (string, optional) - Success message

**Returns:** Promise\\<Notification\\> - Notification object

**Example:**
\`\`\`javascript
await notify.success('Upload Complete', 'File uploaded successfully');
\`\`\`

## COMPLETE EXAMPLES

### Long-running task notification

\`\`\`javascript
// Notify when a long task completes
console.log('Starting long task...');

try {
  // Do some work...
  const result = await http.json('https://api.example.com/process');

  // Notify success
  await notify.success('Task Complete', \`Processed \${result.count} items\`);
} catch (error) {
  // Notify error
  await notify.error('Task Failed', error.message);
}
\`\`\`

### Permission check before notifying

\`\`\`javascript
// Check permission before attempting notification
if (notify.permission() === 'granted') {
  await notify.send('Hello', 'Notification ready to go');
} else if (notify.permission() === 'default') {
  const permission = await notify.requestPermission();
  if (permission === 'granted') {
    await notify.send('Hello', 'Thanks for granting permission');
  }
} else {
  console.log('Notifications are blocked');
}
\`\`\`

### Cron job notification

\`\`\`javascript
// In a cron script that runs periodically
const stats = await fs.stat('/home/data.txt');
const sizeInMB = (stats.size / 1024 / 1024).toFixed(2);

if (stats.size > 10 * 1024 * 1024) {
  await notify.send(
    'Large File Warning',
    \`data.txt is \${sizeInMB} MB\`
  );
}
\`\`\`

## NOTES

- Notifications require user permission - always check or request permission first
- Browser may rate-limit notifications if too many are shown
- Notifications tagged with the same \`tag\` will replace previous notifications
- Use \`requireInteraction: true\` for critical notifications that need user attention
- Currently only functional in UI context; worker context support planned

## SEE ALSO

run(1), cron(1), http(3)
`,

  'path.3.md': `# NAME

path - POSIX path manipulation utilities for Koma scripts

## SYNOPSIS

\`\`\`javascript
// Available in scripts as 'path' module
const fullPath = path.join('/home', 'user', 'file.txt');
const dir = path.dirname('/home/user/file.txt');
const file = path.basename('/home/user/file.txt');
const ext = path.extname('file.txt');
\`\`\`

## DESCRIPTION

The \`path\` module provides utilities for working with file paths in a POSIX-style virtual filesystem. All functions work synchronously and use forward slashes (/) as the path separator.

## CONSTANTS

### path.sep

Path separator character. Always \`'/'\` in Koma's POSIX filesystem.

**Example:**
\`\`\`javascript
console.log(path.sep); // '/'
\`\`\`

## FUNCTIONS

### path.join(...segments)

Join path segments into a single normalized path.

**Parameters:**
- \`...segments\` (string) - Path segments to join

**Returns:** string - Joined and normalized path

**Example:**
\`\`\`javascript
path.join('/home', 'user', 'file.txt');  // '/home/user/file.txt'
path.join('/home', '../etc');            // '/etc'
path.join('foo', 'bar', 'baz');          // 'foo/bar/baz'
path.join('/home/', '/', 'user');        // '/home/user'
\`\`\`

### path.resolve(...segments)

Resolve path segments to an absolute path. Processes segments from right to left until an absolute path is constructed.

**Parameters:**
- \`...segments\` (string) - Path segments to resolve

**Returns:** string - Absolute path

**Example:**
\`\`\`javascript
path.resolve('/home', 'user', 'file.txt');  // '/home/user/file.txt'
path.resolve('user', 'file.txt');           // '/user/file.txt'
path.resolve('/foo', '/bar', 'baz');        // '/bar/baz'
\`\`\`

### path.dirname(path)

Get the directory portion of a path.

**Parameters:**
- \`path\` (string) - Path to process

**Returns:** string - Directory name

**Example:**
\`\`\`javascript
path.dirname('/home/user/file.txt');  // '/home/user'
path.dirname('/home/user/');          // '/home'
path.dirname('/home');                // '/'
path.dirname('/');                    // '/'
path.dirname('file.txt');             // '.'
\`\`\`

### path.basename(path, ext)

Get the filename portion of a path. Optionally removes a file extension.

**Parameters:**
- \`path\` (string) - Path to process
- \`ext\` (string, optional) - Extension to remove (including dot)

**Returns:** string - Base filename

**Example:**
\`\`\`javascript
path.basename('/home/user/file.txt');        // 'file.txt'
path.basename('/home/user/file.txt', '.txt'); // 'file'
path.basename('/home/user/');                // 'user'
path.basename('file.txt');                   // 'file.txt'
\`\`\`

### path.extname(path)

Get the file extension from a path, including the leading dot.

**Parameters:**
- \`path\` (string) - Path to process

**Returns:** string - File extension (including dot), or empty string if no extension

**Example:**
\`\`\`javascript
path.extname('/home/user/file.txt');    // '.txt'
path.extname('/home/user/file.tar.gz'); // '.gz'
path.extname('/home/user/file');        // ''
path.extname('/home/user/.bashrc');     // ''
path.extname('file.');                  // ''
\`\`\`

### path.normalize(path)

Normalize a path by resolving \`.\` and \`..\` segments and removing duplicate slashes.

**Parameters:**
- \`path\` (string) - Path to normalize

**Returns:** string - Normalized path

**Example:**
\`\`\`javascript
path.normalize('/home/user/../admin');   // '/home/admin'
path.normalize('/home/./user');          // '/home/user'
path.normalize('//home///user//');       // '/home/user'
path.normalize('/home/user/..');         // '/home'
path.normalize('foo/../bar');            // 'bar'
\`\`\`

### path.relative(from, to)

Get the relative path from one location to another.

**Parameters:**
- \`from\` (string) - Source path
- \`to\` (string) - Destination path

**Returns:** string - Relative path

**Example:**
\`\`\`javascript
path.relative('/home/user', '/home/admin');      // '../admin'
path.relative('/home/user', '/home/user/docs');  // 'docs'
path.relative('/home/user', '/home/user');       // ''
path.relative('/home/user', '/etc');             // '../../etc'
\`\`\`

### path.isAbsolute(path)

Check if a path is absolute (starts with /).

**Parameters:**
- \`path\` (string) - Path to check

**Returns:** boolean - True if absolute path

**Example:**
\`\`\`javascript
path.isAbsolute('/home/user');  // true
path.isAbsolute('user/docs');   // false
path.isAbsolute('../foo');      // false
path.isAbsolute('/');           // true
\`\`\`

## COMPLETE EXAMPLES

### Build output path from components

\`\`\`javascript
const projectDir = '/home/projects/myapp';
const buildDir = 'dist';
const filename = 'bundle.js';

const outputPath = path.join(projectDir, buildDir, filename);
console.log(outputPath); // '/home/projects/myapp/dist/bundle.js'
\`\`\`

### Parse file path information

\`\`\`javascript
const filePath = '/home/user/documents/report.pdf';

const dir = path.dirname(filePath);      // '/home/user/documents'
const file = path.basename(filePath);    // 'report.pdf'
const name = path.basename(filePath, path.extname(filePath)); // 'report'
const ext = path.extname(filePath);      // '.pdf'

console.log(\`Directory: \${dir}\`);
console.log(\`Filename: \${file}\`);
console.log(\`Name: \${name}\`);
console.log(\`Extension: \${ext}\`);
\`\`\`

### Resolve relative imports

\`\`\`javascript
// Resolve a relative import from current file
const currentFile = '/home/projects/src/components/button.js';
const importPath = '../utils/helpers.js';

const currentDir = path.dirname(currentFile);
const resolvedPath = path.resolve(currentDir, importPath);

console.log(resolvedPath); // '/home/projects/src/utils/helpers.js'
\`\`\`

### File operations with path utilities

\`\`\`javascript
// Build paths for file operations
const baseDir = env.HOME;
const configFile = path.join(baseDir, 'config', 'app.json');

// Check if config exists
if (await fs.exists(configFile)) {
  const content = await fs.readFile(configFile);
  console.log('Config loaded from:', configFile);
} else {
  // Create config directory if needed
  const configDir = path.dirname(configFile);
  await fs.mkdir(configDir);

  // Create default config
  await fs.writeFile(configFile, '{}');
  console.log('Created config at:', configFile);
}
\`\`\`

### Calculate relative paths for links

\`\`\`javascript
// Generate relative path for file references
const pageFile = '/home/projects/docs/pages/about.html';
const cssFile = '/home/projects/docs/styles/main.css';

const relativePath = path.relative(
  path.dirname(pageFile),
  cssFile
);

console.log(\`<link href="\${relativePath}">\`);
// <link href="../styles/main.css">
\`\`\`

## NOTES

- All paths use forward slash (/) as separator (POSIX style)
- Absolute paths start with /
- \`.\` represents current directory
- \`..\` represents parent directory
- Multiple consecutive slashes are treated as a single slash
- Trailing slashes are generally ignored
- Empty path returns \`'.'\` (current directory)

## SEE ALSO

fs(3), cd(1), pwd(1), ls(1)
`

};
